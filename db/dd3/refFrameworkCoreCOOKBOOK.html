<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Project: Core COOKBOOK</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../o2_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('db/dd3/refFrameworkCoreCOOKBOOK.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Core COOKBOOK</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Data Processing Layer Cookbook</h1>
<p>This is a work in progress entrypoint for common DPL related tasks.</p>
<h4>Utilities for working with <code>DataRef</code></h4>
<p>Get payload size: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> payloadSize = DataRefUtils::getPayloadSize(<a class="code hl_class" href="../../d1/da0/classint.html">ref</a>);</div>
<div class="ttc" id="aclassint_html"><div class="ttname"><a href="../../d1/da0/classint.html">int</a></div></div>
</div><!-- fragment --><p>Extract a header from the header stack: </p><div class="fragment"><div class="line"><span class="keyword">const</span> HeaderType* header = DataRefUtils::getHeader&lt;HeaderType*&gt;(<a class="code hl_class" href="../../d1/da0/classint.html">ref</a>);</div>
</div><!-- fragment --><p>Get the payload of messageable type as <code>gsl::span</code> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_typedef" href="../../dc/da3/glcorearb_8h.html#a8922a680b00df660c57f47c1971d04c5">data</a> = DataRefUtils::as&lt;T&gt;(<a class="code hl_class" href="../../d1/da0/classint.html">ref</a>);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element : <a class="code hl_typedef" href="../../dc/da3/glcorearb_8h.html#a8922a680b00df660c57f47c1971d04c5">data</a>) {</div>
<div class="line">  <span class="comment">// do something on element, remember it&#39;s const</span></div>
<div class="line">}</div>
<div class="ttc" id="aglcorearb_8h_html_a8922a680b00df660c57f47c1971d04c5"><div class="ttname"><a href="../../dc/da3/glcorearb_8h.html#a8922a680b00df660c57f47c1971d04c5">data</a></div><div class="ttdeci">GLboolean * data</div><div class="ttdef"><b>Definition</b> <a href="../../dc/da3/glcorearb_8h_source.html#l00298">glcorearb.h:298</a></div></div>
</div><!-- fragment --><h4>How do I report failure for a given Algorithm?</h4>
<p>Whenever the driver process spots an error message, i.e. an error printed via <code>LOG(error)</code> facility, when the driver process quits, it will exit with a exit code of 1. This includes any exception reported by the default exception handler.</p>
<p>This comes handy, for example in tests.</p>
<h3>Debugging on your laptop</h3>
<p>The way the DPL currently works is that the driver executable you launch, will then take care of spawning one device per <code>DataProcessorSpec</code> in a separate process. This means that in order to debug your code you need to make sure gdb / lldb are actually debugging the right child process.</p>
<p>For <code>gdb</code> you can use the <code>follow-fork-mode</code> setting. See <a href="https://sourceware.org/gdb/onlinedocs/gdb/Forks.html">here</a> for the full documentation. This is unfortunately not available in <a href="https://bugs.llvm.org/show_bug.cgi?id=17972">lldb</a>.</p>
<p>Alternatively you can start your driver executable with the <code>-s</code> / <code>--stop</code> command line option which will immediately stop execution of the children after the fork, allowing you to attach to them, e.g. for gdb using:</p>
<div class="fragment"><div class="line">attach &lt;pid&gt;</div>
</div><!-- fragment --><p>or the <code>lldb</code> equivalent:</p>
<div class="fragment"><div class="line">attach -pid &lt;pid&gt;</div>
</div><!-- fragment --><p> Note: On some systems, attaching might fail due to missing permission, and <code>gdb</code> has to be started with <code>sudo</code>.</p>
<p>Once you have attached to the children you are interested in, make sure you send a SIGCONT to the others by using something along the lines of:</p>
<div class="fragment"><div class="line">kill -SIGCONT &lt;all-other-pids&gt;</div>
</div><!-- fragment --><p>In case you are building the DPL with the support for the debug GUI, you can also attach a debugger to the running process by clicking on the DataProcessorSpec you want to debug, which will show the Device inspector on the right, and there click on the "Attach debugger" button. By default this will start lldb in a Terminal.app window on mac, or GDB in an xterm elsewhere. You can customise this behavior by setting the environment variable <code>O2DPLDEBUG</code> to the command you want to run for the debugger and use the environment variable <code>O2DEBUGGEDPID</code> to get the PID of the DataProcessor currently selected. You can do this multiple times for all the devices you wish to debug, but remember that you will need to quit the debugger if you want DPL to exit.</p>
<p>On linux you might need to start the debugger with <code>sudo</code> to have the permission to attach, e.g. set O2DPLDEBUG to </p><div class="fragment"><div class="line">export O2DPLDEBUG=&#39;xterm -hold -e sudo gdb attach $O2DEBUGGEDPID &amp;&#39;</div>
</div><!-- fragment --><p> Be sure to use single quotes to avoid direct expansion of O2DEBUGGEDPID variable. The <code>&amp;</code> character add the end is needed to start gdb in a separate process.</p>
<h3>Dumping cores</h3>
<p>By default DPL does its best to catch exceptions and avoid core dumps. This behaviour can however be changed by exporting the <code>O2_NO_CATCHALL_EXCEPTIONS</code> environment variable. E.g.:</p>
<div class="fragment"><div class="line">export O2_NO_CATCHALL_EXCEPTIONS=1</div>
</div><!-- fragment --><p>in the shell where you are running your workflow.</p>
<h3>Dumping stacktraces on a signal</h3>
<p>If you are on linux you can get stacktraces on a various signals via the:</p>
<div class="fragment"><div class="line">--stacktrace-on-signal &quot;&lt;signal&gt; [&lt;signal&gt;..]&quot;</div>
</div><!-- fragment --><p>option, where <code>&lt;signal&gt;</code> can be: all, segv, bus, ill, abrt, fpe and sys.</p>
<h3>Debug GUI</h3>
<p>DPL also includes a simple GUI to help debugging problems:</p>
<p><img src="https://user-images.githubusercontent.com/10544/29307499-75bb8550-81a2-11e7-9aa6-96b7613288b5.png" alt="" class="inline"/></p>
<p>The GUI provides the following facilities:</p>
<ul>
<li>Graph view with all the connections between DataProcessors</li>
<li>One log window per DataProcessor, allowing filtering and triggering on log messages</li>
<li>Metrics inspector</li>
<li><a class="el" href="../../d2/d88/classA.html">A</a> Device Inspector</li>
</ul>
<p>by default the GUI runs as natively on your Linux desktop (using OpenGL) or on macOS (using Metal as a back end). It is also possible to run the GUI remotely by exporting the environment variable <code>DPL_DRIVER_REMOTE_GUI</code>, e.g.:</p>
<div class="fragment"><div class="line">export DPL_DRIVER_REMOTE_GUI=1</div>
</div><!-- fragment --><p>Note that in this case your workflow should be started with the <code>-b</code> option and that you should have properly loaded the environment with <code>alienv enter ...</code>. In the stdout you should see the control port of the driver: </p><div class="fragment"><div class="line">[INFO] Driver listening on port: 34855</div>
</div><!-- fragment --><p>Notice you can customise the port to your preference using the <code>DPL_REMOTE_GUI_PORT</code> variable.</p>
<p>In order to connect to this port with your browser you should go to <a href="https://aliceo2group.github.io/DebugGUI/remote/remote.html">https://aliceo2group.github.io/DebugGUI/remote/remote.html</a>, enter the port and click on the <code>LAUNCH</code> button. If you are running the DebugGUI remotely, but still the processing is done on your laptop (e.g. because the native DebugGUI is not working for some reason) you can download the web page and then open the local html file in your browser.</p>
<p><img src="https://user-images.githubusercontent.com/26281793/192991412-f26a271d-919a-4dd5-af2b-6a8425d6d1eb.png" alt="DebugGUI" class="inline"/></p>
<p>After launching you can select "interactive" mode on the right and click on "fit" in order to adjust the visualization to your browser window size. When running everything on one machine you can also reduce the latency from 200 to 80 for example to make it more responsive.</p>
<p><img src="https://user-images.githubusercontent.com/26281793/192991486-7cdb799b-470a-455b-a2de-65b7d9355ec7.png" alt="DebugGUI_Running" class="inline"/></p>
<p>Notice that in this setup, you might have to adjust your browser sensibility to <a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a>. Mac users should try to use Safari if Chrome does not work. In addition, it may be necessary to setup a SOCKS proxy to the remote machine running the DPL workflow.</p>
<h3>Integrating with non-DPL devices</h3>
<p>Given the Data Processing Layer comes somewhat later in the design of O2, it's possible that you already have some topology of devices which you want to integrate, without having to port them to the DPL itself. Alternatively, your devices might not satisfy the requirements of the Data Processing Layer and therefore require a "raw" <code><a class="el" href="../../d0/d70/classfair_1_1mq_1_1Device.html">fair::mq::Device</a></code>, fully customised to your needs. This is fully supported and we provide means to ingest foreign, non-DPL FairMQ devices produced, messages into a DPL workflow. This is done via the help of a "proxy" data processor which connects to the foreign device, receives its inputs, optionally converts them to a format understood by the Data Processing Layer, and then pumps them to the right Data Processor Specs. In order to have such a device in your workflow, you can use the [<code>specifyExternalFairMQDeviceProxy</code>][specifyExternalFairMQDeviceProxy] helper to instanciate it. For an example of how to use it you can look at [<code><a class="el" href="../../da/d19/test__RawDeviceInjector_8cxx.html">Framework/TestWorkflows/src/test_RawDeviceInjector.cxx</a></code>][rawDeviceInjectorExample]. The <code>specifyExternalFairMQDeviceProxy</code> takes four arguments:</p>
<div class="fragment"><div class="line">specifyExternalFairMQDeviceProxy(<span class="stringliteral">&quot;foreign-source&quot;</span>,</div>
<div class="line">                {outspec},</div>
<div class="line">                <span class="stringliteral">&quot;type=sub,method=connect,address=tcp://localhost:5450,rateLogging=1&quot;</span>,</div>
<div class="line">                o2DataModelAdaptor(outspec, 0, 1)</div>
<div class="line">               ),</div>
</div><!-- fragment --><p>the first one is the usual <code>DataProcessorSpec</code> name, the second one is a list of outputs which we will create from the non-DPL device, the third one is a string to connect to the existing topology and a the fourth one is a function of the kind <code><a class="el" href="../../dd/d8d/namespaceo2_1_1framework.html#a67a522c5db13b1e4b7752389d058917e">o2::framework::InjectorFunction</a></code> which does the actual conversion. In this particular case we use the <code>o2DataModelAdaptor()</code> helper to create such an translation function since we know that our input is already respecting the O2 Data <a class="el" href="../../d6/d18/classModel.html">Model</a> and most of the heavylifing can be done automatically.</p>
<p>Sending out the results of a computation can be done in a similar manner. Use</p>
<div class="fragment"><div class="line">ConfigParamSpec{<span class="stringliteral">&quot;channel-config&quot;</span>, VariantType::String, <span class="stringliteral">&quot;&lt;channel-configuration&gt;&quot;</span>, <span class="stringliteral">&quot;Out-of-band channel config&quot;</span>}</div>
</div><!-- fragment --><p>to create an out-of-band channel as specified in <code>channel-configuration</code> and hen use the <code>RawDeviceService</code> to get the raw FairMQDevice and send data hrough such a channel.</p>
<h2>Customizing workflows creation (WIP)</h2>
<p>Sometimes it's handy to customise or generalise the workflow creation based on external inputs. For example you might want to change the number of workers for a given task or disable part of the topology if a given detector should not be enabled.</p>
<p>This can be done by implementing the function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="../../d4/d0a/barrel-alignment-workflow_8cxx.html#af2efa39a03c019e9852d51f121fe68bb">customize</a>(std::vector&lt;o2::framework::ConfigParamSpec&gt; &amp;workflowOptions)</div>
<div class="ttc" id="abarrel-alignment-workflow_8cxx_html_af2efa39a03c019e9852d51f121fe68bb"><div class="ttname"><a href="../../d4/d0a/barrel-alignment-workflow_8cxx.html#af2efa39a03c019e9852d51f121fe68bb">customize</a></div><div class="ttdeci">void customize(std::vector&lt; o2::framework::CallbacksPolicy &gt; &amp;policies)</div><div class="ttdef"><b>Definition</b> <a href="../../d4/d0a/barrel-alignment-workflow_8cxx_source.html#l00042">barrel-alignment-workflow.cxx:42</a></div></div>
</div><!-- fragment --><p><b>before</b> including the <code><a class="el" href="../../db/dd0/runDataProcessing_8h.html">Framework/runDataProcessing.h</a></code> (this will most likely change in the future). Each ConfigParamSpec will be added to the configuration mechanism (e.g. the command line options) allowing you to modify them. Such options will then be made available at workflow creation time via the <code>ConfigContext</code> passed to the <code>defineDataProcessing</code> function, using the <code><a class="el" href="../../d0/dab/classo2_1_1framework_1_1ConfigContext.html#a89750309b89cb165cdbfacbcd85b4bf0">ConfigContext::options()</a></code> getter.</p>
<h2>Completion policies (WIP)</h2>
<p>By default the data processing of a given record happens when all the fields of that record are present. So if your Data Processor declares it will consume <code>TRACKS</code> and <code>CLUSTERS</code>, for any given time interval both need to be produced by some other data processor before the computation declared in yours can happen.</p>
<p>Sometimes it's however desirable to customise such a behavior, so that some action on the record can happen even if it's not complete. For example you might want to start computing some quantity as a given message arrives and then complete the computation once the record is complete. This is done by specifying by customising the data processing CompletionPolicy. This can be done using the usual <b>Customization mechanism</b> where a:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="../../d4/d0a/barrel-alignment-workflow_8cxx.html#af2efa39a03c019e9852d51f121fe68bb">customize</a>(std::vector&lt;CompletionPolicy&gt; &amp;policies);</div>
</div><!-- fragment --><p>function is provided before including <code><a class="el" href="../../db/dd0/runDataProcessing_8h.html">runDataProcessing.h</a></code>.</p>
<p>Each <code>CompletionPolicy</code> requires the user to specify the <code>matcher</code> to select which device is affected by it, and a <code>callback</code> to decide what action expressed by a <code>CompletionOp</code> to take on a given input record.</p>
<p>Possible actions include:</p>
<ul>
<li><code>CompletionPolicy::CompletionOp::Consume</code>: run the data processing callback and mark the available fields in the input as consumed.</li>
<li><code>CompletionPolicy::CompletionOp::Process</code>: run the data processing callback, but do not consume the field, which will be available when the next message for the field</li>
<li><code>CompletionPolicy::CompletionOp::Wait</code>: hold on the record but do not process it yet.</li>
<li><code>CompletionPolicy::CompletionOp::Drop</code>: drop the current available fields from the record.</li>
</ul>
<p>The default completion policy is to consume all inputs when they are all present.</p>
<p>When the computation is dispatched with a partially completea <code>InputRecord</code>, the user can check for the validity of any of its parts via the <code>InputRecord::isValid()</code> API.</p>
<h2>Customizing deployment configuration (WIP)</h2>
<p>By default every device instanciated by the Data Processing Layer connects to the others using the PUB/SUB paradigm. This might or might not be desiderable for some or even all of the connections. For this reason there is now a way to customise the connections based on the ids of the devices being instanciated.</p>
<p>In order to do so, one needs to implement the function</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="../../d4/d0a/barrel-alignment-workflow_8cxx.html#af2efa39a03c019e9852d51f121fe68bb">customize</a>(std::vector&lt;o2::framework::ChannelConfigurationPolicy&gt; &amp;policies)</div>
</div><!-- fragment --><p><b>before</b> including <code><a class="el" href="../../db/dd0/runDataProcessing_8h.html">Framework/runDataProcessing.h</a></code> (this will most likely change in the future). You can then extend the policies vector with your own <code>ChannelConfigurationPolicy</code>. For each device to device edge, the system will invoke the <code>ChannelConfigurationPolicy::match</code> callback with the ids of the producer and of the consumer as arguments. If the callback returns <code>true</code>, the <code>ChannelConfigurationPolicy::modifyInput</code> and <code>ChannelConfigurationPolicy::modifyOutput</code> will be invoked passing the input and output channel associated to the two devices, giving the opportunity to modify the matching channels.</p>
<h2>Getting objects from the CCDB</h2>
<p>In order to get objects from the CCDB one can specify the <code>Lifetime::Condition</code> for the required input spec. That will retrieve the object not from another data processor but it will do a request to a CCDB server. The actual URL for the server can be specified via the <code>--condition-backend &lt;backend-url&gt;</code> option. It is also possible to specify a given timestamp for the object via the option <code>--condition-timestamp &lt;timestamp&gt;</code>. The final url is completed by the value of the the Origin and Description of the <code>InputSpec</code> to be:</p>
<div class="fragment"><div class="line">&lt;backend-url&gt;/&lt;origin&gt;/&lt;description&gt;/&lt;timestamp&gt;</div>
</div><!-- fragment --><p>If the timestamp is not specified, DPL will look it up in the <code>DataProcessingHeader</code>.</p>
<h2>Lifetime support</h2>
<p>While initially foreseen in the design, Lifetime for Inputs / Outputs has not yet being implemented correctly. However, once that happens, the following behaviors will be implemented (naming foreseen to change). Once implemented it will be possible to specify the following Lifetime types:</p>
<ul>
<li>Timeframe: an input that gets processed only once.</li>
<li>Condition: an input that is cache on considered valid for multiple computations, according to its IOV.</li>
<li>Transient: an output which is not actually sent. Useful to use the same mechanism of the Message Passing API to create</li>
<li>QA: an output which once send is also proposed as input to the subsequent computation, allowing for accumulating data (e.g. histograms).</li>
</ul>
<h2>Wildcard support for InputSpec / OutputSpec</h2>
<p>In order to reduce the amount of code which one has to write to define inputs and outputs, we plan to make the InputSpecs and OutputSpecs as veritable matchers, supporting wildcards. For example if your Algorithm supports processing clusters coming from multiple detectors, it will be possible to specify:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../da/d96/structo2_1_1framework_1_1InputSpec.html">InputSpec</a>{<span class="stringliteral">&quot;*&quot;</span>, <span class="stringliteral">&quot;CLUSTERS&quot;</span>}</div>
<div class="ttc" id="astructo2_1_1framework_1_1InputSpec_html"><div class="ttname"><a href="../../da/d96/structo2_1_1framework_1_1InputSpec.html">o2::framework::InputSpec</a></div><div class="ttdef"><b>Definition</b> <a href="../../d5/d3f/InputSpec_8h_source.html#l00031">InputSpec.h:31</a></div></div>
</div><!-- fragment --><p>If the user wants to get both clusters and tracks coming from the same detector, it will be possible to write:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../da/d96/structo2_1_1framework_1_1InputSpec.html">InputSpec</a>{<span class="stringliteral">&quot;*&quot;</span>, <span class="stringliteral">&quot;CLUSTERS&quot;</span>}, <a class="code hl_struct" href="../../da/d96/structo2_1_1framework_1_1InputSpec.html">InputSpec</a>{<span class="stringliteral">&quot;*&quot;</span>, <span class="stringliteral">&quot;TRACKS&quot;</span>}</div>
</div><!-- fragment --><p>i.e. the first message which arrives will define the wildcard for all the other input spec in the definition.</p>
<h2>Building a data query by string</h2>
<p>The C++ API is not the only way an InputSpec can be constructed. This can be done also by string via the <code>DataDescriptorQueryBuilder::parse</code> method. E.g.:</p>
<div class="fragment"><div class="line">DataDescriptorQueryBuilder::parse(<span class="stringliteral">&quot;label:orig/description/0?lifetime=condition&quot;</span>);</div>
</div><!-- fragment --><p>is equivalent of:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../da/d96/structo2_1_1framework_1_1InputSpec.html">InputSpec</a>{<span class="stringliteral">&quot;label&quot;</span>, <span class="stringliteral">&quot;orig&quot;</span>, <span class="stringliteral">&quot;description&quot;</span>, 0, Lifetime::Condition};</div>
</div><!-- fragment --><h3>Data flow parallelism</h3>
<p>Data flow parallelism is simply expressed by tuning the data flow, adding explicitly the parallel data paths, using the appropriate <code>InputSpec</code> and <code>OutputSpec</code>.</p>
<p>E.g.:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="../../d0/d16/structo2_1_1framework_1_1DataProcessorSpec.html">DataProcessorSpec</a>{</div>
<div class="line">  <span class="stringliteral">&quot;tpc_processor_1&quot;</span>,</div>
<div class="line">  Inputs{},</div>
<div class="line">  Outputs{{<span class="stringliteral">&quot;TPC&quot;</span>, <span class="stringliteral">&quot;CLUSTERS&quot;</span>, <a class="code hl_typedef" href="../../d2/d23/dataSamplingBenchmark_8cxx.html#a350f3783408f572381ffe5cb7a6c449e">SubSpec</a>(0)}},</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">},</div>
<div class="line"><a class="code hl_struct" href="../../d0/d16/structo2_1_1framework_1_1DataProcessorSpec.html">DataProcessorSpec</a>{</div>
<div class="line">  <span class="stringliteral">&quot;tpc_processor_2&quot;</span>,</div>
<div class="line">  <a class="code hl_typedef" href="../../dd/d8d/namespaceo2_1_1framework.html#ae0fa8f5b8c413d923205bbe985f08602">Inputs</a>{},</div>
<div class="line">  <a class="code hl_typedef" href="../../dd/d8d/namespaceo2_1_1framework.html#af99101fa4f6d5dd76f39eb050f2b2d2a">Outputs</a>{{<span class="stringliteral">&quot;TPC&quot;</span>, <span class="stringliteral">&quot;CLUSTERS&quot;</span>, <a class="code hl_typedef" href="../../d2/d23/dataSamplingBenchmark_8cxx.html#a350f3783408f572381ffe5cb7a6c449e">SubSpec</a>(1)}},</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><a class="code hl_struct" href="../../d0/d16/structo2_1_1framework_1_1DataProcessorSpec.html">DataProcessorSpec</a>{</div>
<div class="line">  <span class="stringliteral">&quot;tpc_processor_18&quot;</span>,</div>
<div class="line">  <a class="code hl_typedef" href="../../dd/d8d/namespaceo2_1_1framework.html#ae0fa8f5b8c413d923205bbe985f08602">Inputs</a>{},</div>
<div class="line">  <a class="code hl_typedef" href="../../dd/d8d/namespaceo2_1_1framework.html#af99101fa4f6d5dd76f39eb050f2b2d2a">Outputs</a>{{<span class="stringliteral">&quot;TPC&quot;</span>, <span class="stringliteral">&quot;CLUSTERS&quot;</span>, <a class="code hl_typedef" href="../../d2/d23/dataSamplingBenchmark_8cxx.html#a350f3783408f572381ffe5cb7a6c449e">SubSpec</a>(17)}},</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="ttc" id="adataSamplingBenchmark_8cxx_html_a350f3783408f572381ffe5cb7a6c449e"><div class="ttname"><a href="../../d2/d23/dataSamplingBenchmark_8cxx.html#a350f3783408f572381ffe5cb7a6c449e">SubSpec</a></div><div class="ttdeci">o2::header::DataHeader::SubSpecificationType SubSpec</div><div class="ttdef"><b>Definition</b> <a href="../../d2/d23/dataSamplingBenchmark_8cxx_source.html#l00061">dataSamplingBenchmark.cxx:61</a></div></div>
<div class="ttc" id="anamespaceo2_1_1framework_html_ae0fa8f5b8c413d923205bbe985f08602"><div class="ttname"><a href="../../dd/d8d/namespaceo2_1_1framework.html#ae0fa8f5b8c413d923205bbe985f08602">o2::framework::Inputs</a></div><div class="ttdeci">std::vector&lt; InputSpec &gt; Inputs</div><div class="ttdef"><b>Definition</b> <a href="../../d0/df4/DataProcessorSpec_8h_source.html#l00029">DataProcessorSpec.h:29</a></div></div>
<div class="ttc" id="anamespaceo2_1_1framework_html_af99101fa4f6d5dd76f39eb050f2b2d2a"><div class="ttname"><a href="../../dd/d8d/namespaceo2_1_1framework.html#af99101fa4f6d5dd76f39eb050f2b2d2a">o2::framework::Outputs</a></div><div class="ttdeci">std::vector&lt; OutputSpec &gt; Outputs</div><div class="ttdef"><b>Definition</b> <a href="../../d0/df4/DataProcessorSpec_8h_source.html#l00030">DataProcessorSpec.h:30</a></div></div>
<div class="ttc" id="astructo2_1_1framework_1_1DataProcessorSpec_html"><div class="ttname"><a href="../../d0/d16/structo2_1_1framework_1_1DataProcessorSpec.html">o2::framework::DataProcessorSpec</a></div><div class="ttdef"><b>Definition</b> <a href="../../d0/df4/DataProcessorSpec_8h_source.html#l00041">DataProcessorSpec.h:41</a></div></div>
</div><!-- fragment --><p>or alternatively the parallel workflows part could be generated programmatically:</p>
<div class="fragment"><div class="line">parallel(</div>
<div class="line">  <a class="code hl_struct" href="../../d0/d16/structo2_1_1framework_1_1DataProcessorSpec.html">DataProcessorSpec</a>{</div>
<div class="line">    <span class="stringliteral">&quot;tpc_processor&quot;</span>,</div>
<div class="line">    {<a class="code hl_struct" href="../../da/d96/structo2_1_1framework_1_1InputSpec.html">InputSpec</a>{<span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;TPC&quot;</span>, <span class="stringliteral">&quot;CLUSTERS&quot;</span>}}</div>
<div class="line">  },</div>
<div class="line">  18,</div>
<div class="line">  [](<a class="code hl_struct" href="../../d0/d16/structo2_1_1framework_1_1DataProcessorSpec.html">DataProcessorSpec</a> &amp;spec, <span class="keywordtype">size_t</span> idx) {</div>
<div class="line">    spec.<a class="code hl_variable" href="../../d0/d16/structo2_1_1framework_1_1DataProcessorSpec.html#a7997d84d3a2681f039e59c0c91c1d5d9">outputs</a>[0].subSpec = idx; <span class="comment">// Each of the 18 DataProcessorSpecs should have a different subSpec</span></div>
<div class="line">  }</div>
<div class="line">)</div>
<div class="ttc" id="astructo2_1_1framework_1_1DataProcessorSpec_html_a7997d84d3a2681f039e59c0c91c1d5d9"><div class="ttname"><a href="../../d0/d16/structo2_1_1framework_1_1DataProcessorSpec.html#a7997d84d3a2681f039e59c0c91c1d5d9">o2::framework::DataProcessorSpec::outputs</a></div><div class="ttdeci">Outputs outputs</div><div class="ttdef"><b>Definition</b> <a href="../../d0/df4/DataProcessorSpec_8h_source.html#l00044">DataProcessorSpec.h:44</a></div></div>
</div><!-- fragment --><p>Similarly this can be done for a component that merges inputs from multiple parallel devices, this time by modifying programmatically the <code>Inputs</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"><a class="code hl_struct" href="../../d0/d16/structo2_1_1framework_1_1DataProcessorSpec.html">DataProcessorSpec</a>{</div>
<div class="line">  <span class="stringliteral">&quot;merger&quot;</span>,</div>
<div class="line">  mergeInputs({<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;TST&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>, 0, Lifetime::Timeframe},</div>
<div class="line">              4,</div>
<div class="line">              [](<a class="code hl_struct" href="../../da/d96/structo2_1_1framework_1_1InputSpec.html">InputSpec</a> &amp;input, <span class="keywordtype">size_t</span> <a class="code hl_typedef" href="../../dc/da3/glcorearb_8h.html#a57f14e05b1900f16a2da82ade47d0c6d">index</a>) {</div>
<div class="line">                 input.subSpec = <a class="code hl_typedef" href="../../dc/da3/glcorearb_8h.html#a57f14e05b1900f16a2da82ade47d0c6d">index</a>;</div>
<div class="line">              }</div>
<div class="line">          ),</div>
<div class="line">  {},</div>
<div class="line">  AlgorithmSpec{[](InitContext &amp;setup) {</div>
<div class="line">     <span class="keywordflow">return</span> [](ProcessingContext &amp;ctx) {</div>
<div class="line">  <span class="comment">// Create a single output.</span></div>
<div class="line">    <a class="code hl_function" href="../../dc/da7/test__ctf__io__cpv_8cxx.html#a1ef7964b771b9b29688dfa8810b27d00">LOG</a>(<a class="code hl_variable" href="../../d4/d67/VariantJSONHelpers_8cxx.html#a92b9653745b1ddd58664de621c944ba2">debug</a>) &lt;&lt; <span class="stringliteral">&quot;Invoked&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="ttc" id="aVariantJSONHelpers_8cxx_html_a92b9653745b1ddd58664de621c944ba2"><div class="ttname"><a href="../../d4/d67/VariantJSONHelpers_8cxx.html#a92b9653745b1ddd58664de621c944ba2">debug</a></div><div class="ttdeci">std::ostringstream debug</div><div class="ttdef"><b>Definition</b> <a href="../../d4/d67/VariantJSONHelpers_8cxx_source.html#l00305">VariantJSONHelpers.cxx:305</a></div></div>
<div class="ttc" id="aglcorearb_8h_html_a57f14e05b1900f16a2da82ade47d0c6d"><div class="ttname"><a href="../../dc/da3/glcorearb_8h.html#a57f14e05b1900f16a2da82ade47d0c6d">index</a></div><div class="ttdeci">GLuint index</div><div class="ttdef"><b>Definition</b> <a href="../../dc/da3/glcorearb_8h_source.html#l00781">glcorearb.h:781</a></div></div>
<div class="ttc" id="atest__ctf__io__cpv_8cxx_html_a1ef7964b771b9b29688dfa8810b27d00"><div class="ttname"><a href="../../dc/da7/test__ctf__io__cpv_8cxx.html#a1ef7964b771b9b29688dfa8810b27d00">LOG</a></div><div class="ttdeci">LOG(info)&lt;&lt; &quot;Compressed in &quot;&lt;&lt; sw.CpuTime()&lt;&lt; &quot; s&quot;</div></div>
</div><!-- fragment --><p>When one declares a parallel set of devices you can retrieve the rank (i.e. parallel id) or the number of parallel devices by using the <code>ParalleContext</code>, which can be retrieved from the <code>ServiceRegistry</code> (see also the <code>Services</code> section below), e.g.:</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> whoAmI = services.get&lt;ParallelContext&gt;().index1D();</div>
<div class="line"><span class="keywordtype">size_t</span> howManyAreWe = services.get&lt;ParallelContext&gt;().index1DSize();</div>
</div><!-- fragment --><h3>Time pipelining</h3>
<p><a class="el" href="../../d2/d88/classA.html">A</a> second type of parallelism is time based pipelining. This assumes that the data can be subdivided in subsequent "time periods" that are independent one from the other and which are each identified by some timestamp entity. In this particular case it could result handy that some part of the workflow are actually processing different time periods. This can be expressed via the <code>timePipeline</code>, directive, e.g.:</p>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line">timePipeline(<a class="code hl_struct" href="../../d0/d16/structo2_1_1framework_1_1DataProcessorSpec.html">DataProcessorSpec</a>{</div>
<div class="line">  <span class="stringliteral">&quot;processor&quot;</span>,</div>
<div class="line">  {<a class="code hl_struct" href="../../da/d96/structo2_1_1framework_1_1InputSpec.html">InputSpec</a>{<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;TST&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>}},</div>
<div class="line">  {<a class="code hl_struct" href="../../d8/dc3/structo2_1_1framework_1_1OutputSpec.html">OutputSpec</a>{<span class="stringliteral">&quot;TST&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>}},</div>
<div class="line">  AlgorithmSpec{[](ProcessingContext &amp;ctx) {</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line">}, 2);</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="ttc" id="astructo2_1_1framework_1_1OutputSpec_html"><div class="ttname"><a href="../../d8/dc3/structo2_1_1framework_1_1OutputSpec.html">o2::framework::OutputSpec</a></div><div class="ttdef"><b>Definition</b> <a href="../../db/d2d/OutputSpec_8h_source.html#l00033">OutputSpec.h:33</a></div></div>
</div><!-- fragment --><p>which will result in two devices, one for even time periods, the other one for odd timeperiods. This can also be achieved on the command line via the <code>--pipeline &lt;processor name&gt;:&lt;N&gt;</code> option, e.g. <code>--pipeline processor:2</code> in this case.</p>
<p>You can get programmatically the number of time pipelined devices you belong and the rank by looking it up in the <code>DeviceSpec</code>, e.g.:</p>
<div class="fragment"><div class="line">ctx.services().get&lt;<span class="keyword">const</span> <a class="code hl_struct" href="../../df/dce/structo2_1_1framework_1_1DeviceSpec.html">o2::framework::DeviceSpec</a>&gt;().inputTimesliceId;</div>
<div class="line">ctx.<a class="code hl_variable" href="../../df/dce/structo2_1_1framework_1_1DeviceSpec.html#aecc7fc2e5b01774b73e88f159bcabd9f">services</a>().get&lt;<span class="keyword">const</span> <a class="code hl_struct" href="../../df/dce/structo2_1_1framework_1_1DeviceSpec.html">o2::framework::DeviceSpec</a>&gt;().maxInputTimeslices;</div>
<div class="ttc" id="astructo2_1_1framework_1_1DeviceSpec_html"><div class="ttname"><a href="../../df/dce/structo2_1_1framework_1_1DeviceSpec.html">o2::framework::DeviceSpec</a></div><div class="ttdef"><b>Definition</b> <a href="../../df/de8/DeviceSpec_8h_source.html#l00048">DeviceSpec.h:48</a></div></div>
<div class="ttc" id="astructo2_1_1framework_1_1DeviceSpec_html_aecc7fc2e5b01774b73e88f159bcabd9f"><div class="ttname"><a href="../../df/dce/structo2_1_1framework_1_1DeviceSpec.html#aecc7fc2e5b01774b73e88f159bcabd9f">o2::framework::DeviceSpec::services</a></div><div class="ttdeci">std::vector&lt; ServiceSpec &gt; services</div><div class="ttdef"><b>Definition</b> <a href="../../df/de8/DeviceSpec_8h_source.html#l00058">DeviceSpec.h:58</a></div></div>
</div><!-- fragment --><p>Where ctx is either the ProcessingContext or the InitContext.</p>
<h3>Vectorised input</h3>
<p>Sometimes data processing requires to group together multiple messages in one single multipart vector, so that they can be multiplexed on the same InputSpec. This is in particular the case for the RAW data coming out of the (Sub)TFBuilder. In order to do so you need to make sure that the sender sends all the parts to be multiplexed in a single go. On the receiving side, you will get a single entry in the InputRecord and you can get the number of combined parts via <code>InputRecord::getNoParts()</code>. You can each of the parts by providing the entra parameter parts to the <code>InputRecord::get()</code> method.</p>
<h3>Using command line options in DataProcessorSpec</h3>
<p>Command line options for a given DataProcessorSpec are defined as a std::vector&lt;ConfigParamSpec&gt;.</p>
<p><a class="el" href="../../d2/d88/classA.html">A</a> ConfigParamSpec is defined by the 4 arguments</p><ul>
<li>name</li>
<li>type</li>
<li>default</li>
<li>help</li>
</ul>
<p>or with a constructor using only 3 arguments (without the default value).</p>
<p>E.g. </p><div class="fragment"><div class="line">{ {<span class="stringliteral">&quot;opt1&quot;</span>, VariantType::String, <span class="stringliteral">&quot;def1&quot;</span>, {<span class="stringliteral">&quot;Command line option 1&quot;</span>}},    <span class="comment">// constructor with default value def1</span></div>
<div class="line">  {<span class="stringliteral">&quot;opt2&quot;</span>, VariantType::Int, {<span class="stringliteral">&quot;Command line option 2&quot;</span>}},               <span class="comment">// constructor without default value</span></div>
<div class="line">  {<span class="stringliteral">&quot;opt3&quot;</span>, VariantType::Float, 10., {<span class="stringliteral">&quot;Command line option 3&quot;</span>}} }</div>
</div><!-- fragment --><p>(the available VariantType are listed in <a class="el" href="../../de/d56/Variant_8h.html">Framework/Variant.h</a>).</p>
<p>The options are internally filled into an object of type ConfigParamRegistry and forwarded to the InitCallback of the respective AlgorithmSpec as part of the argument of type InitContext. The ConfigParamRegistry is finally accessed with InitContext::options().</p>
<p>E.g. </p><div class="fragment"><div class="line">ConfigParamRegistry opts = ic.options();  <span class="comment">// with InitContext ic;</span></div>
</div><!-- fragment --><p>ConfigParamRegistry has the two methods <code>isSet(key)</code> and <code>get&lt;T&gt;(key)</code>.</p>
<p>To read the option value use the <code>get&lt;T&gt;</code> method with the appropriate type <code>T</code>, e.g.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> vopt1 = ic.options().get&lt;std::string&gt;(<span class="stringliteral">&quot;opt1&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> vopt2 = ic.options().get&lt;std::int&gt;(<span class="stringliteral">&quot;opt2&quot;</span>);</div>
</div><!-- fragment --><p>To test wether the option <code>key</code> was set on the command line the method <code>isSet(key)</code> can be used. However be aware that the method <code>isSet(key)</code> with an option defined with a default value (constructor with 4 arguments) will always return <code>true</code>. If the option was set on the command line, then it will have the respective set value. If it is not set on the command line then it will have the default value. On the other hand an option defined without a default value (constructor with 3 arguments) will only be recognized as set if it indeed was set on the command line. If it was not set, then its value will be undefined. Thus to read an option without default value do e.g.</p>
<div class="fragment"><div class="line">std::string vopt1(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (ic.options().isSet(<span class="stringliteral">&quot;opt1&quot;</span>)) {</div>
<div class="line">  vopt1 = ic.options().get&lt;std::string&gt;(<span class="stringliteral">&quot;opt1&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Monitoring</h2>
<p>By default DPL exposes the following metrics to the back-end specified with: <code>--monitoring-backend</code>:</p>
<ul>
<li><code>malformed_inputs</code>: number of messages which did not match the O2 DataModel</li>
<li><code>dropped_computations</code>: number of messages which DPL could not process</li>
<li><code>dropped_incoming_messages</code>: number of messages which DPL could not accept in its own queue.</li>
<li><code>relayed_messages</code>: number of messages received by DPL.</li>
<li><code>errors</code>: number of errors recorded inside DPL (not in the actual processing).</li>
<li><code>exceptions</code>: number of exceptions raised by the DPL.</li>
<li><code>inputs/relayed/pending</code>: number of entries in the DPL queue which are waiting for extra data.</li>
<li><code>inputs/relayed/incomplete</code> : 1 if the device is waiting for extra data.</li>
<li><code>inputs/relayed/total</code>: how many inputs the processor has.</li>
<li><code>elapsed_time_ms</code>:</li>
<li><code>last_processed_input_size_byte</code>: how many bytes were processed on last iteration by a given device</li>
<li><code>total_processed_input_size_byte</code>: how many bytes were processed in total since the beginning a given device</li>
<li><code>last_processing_rate_mb_s</code>: at what rate the last message was processed</li>
<li><code>min_input_latency_ms</code>: the shortest it took for any message to be processed by this dataprocessor (since created)</li>
<li><code>max_input_latency_ms</code>: the maximum it took for any message to be processed by this dataprocessor (since created)</li>
<li><code>input_rate_mb_s</code>:</li>
</ul>
<p>Moreover if you specify <code>--resources-monitoring &lt;poll-interval&gt;</code> the process monitoring metrics described at:</p>
<p><a href="https://github.com/AliceO2Group/Monitoring/#process-monitoring">https://github.com/AliceO2Group/Monitoring/#process-monitoring</a></p>
<p>will be pushed every <code>&lt;poll-interval&gt;</code> seconds to the same backend and dumped in the <code>performanceMetrics.json</code> file on exit.</p>
<p>One can also specify <code>--resources-monitoring-dump-interval &lt;interval in seconds&gt;</code> to regularly dump the file at a give interval.</p>
<p><a class="el" href="../../d2/d88/classA.html">A</a> value of 0 for the interval will disable the monitoring.</p>
<h3>Disabling monitoring</h3>
<p>Sometimes (e.g. when running a child inside valgrind) it might be useful to disable metrics which might pollute STDOUT. In order to disable monitoring you can use the <code>no-op://</code> backend:</p>
<div class="fragment"><div class="line">some-workflow --monitoring-backend=no-op://</div>
</div><!-- fragment --><p>notice that the will not function properly if you do so.</p>
<h2>Profiling</h2>
<p>The DPL GUI comes with support to run a profiler on a device for 30s. In order to do so you must click on the device you want to profile, which will show the device inspector for the selected device on the right. Then you can click on "Profile 30s" to start the profiler on the selected dataprocessor.</p>
<p>By default results are either dumped to a <code>perf-$O2PROFILEDPID.data</code> (on linux) or displayed in Instruments (on macOS). In order to visualise the perf file you have to then convert it to a flamegraph via:</p>
<div class="fragment"><div class="line">perf script -i perf.data &gt; profile.linux-perf.txt</div>
</div><!-- fragment --><p>and then you can either upload it to <a href="https://www.speedscope.app">https://www.speedscope.app</a> or use chrome://tracing.</p>
<h2>Internal debug log streams</h2>
<p>Debug log entries for several DPL components are now provided via the Signpost API.</p>
<p>Such streams can be enabled using the "Signpost" part of the Device Inspector GUI or alternatively from the command line, by specifying the <code>--signposts &lt;log name&gt;,...</code> option or exporting the variable <code>DPL_SIGNPOSTS=&lt;log name&gt;,...</code>).</p>
<p>Streams can be explicitly enabled or disabled in code using the <code>O2_SIGNPOST_ENABLE()</code> and <code>O2_SIGNPOST_DISABLE</code> macros.</p>
<p>If a process is already running and you wish to enable one or more of its signposts logs, you can do so using the <code>o2-log</code> utility, passing the address of the log to enable and the PID of the running process. E.g. <code>o2-log -p &lt;PID&gt; -a &lt;hook address of the signpost&gt;</code>.</p>
<p>Finally, on macOS, you can also use Instruments to visualise your Signpost, just like any other macOS application. In order to do so you need to enable the "Signpost" instrument, making sure you add <code>ch.cern.aliceo2.completion</code> to the list of loggers to watch. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d8/d3a/refFramework.html">Module &#39;Framework&#39;</a></li><li class="navelem"><a class="el" href="../../d4/d0b/refFrameworkCore.html">Core</a></li>
    <li class="footer">Generated on Fri Oct 31 2025 12:28:23 for Project by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
