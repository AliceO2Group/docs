<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Project: Detector Simulation</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../o2_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('de/dc7/refdocDetectorSimulation.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Detector Simulation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Detector simulation documentation</h1>
<p>The present document collects information about the ALICE detector simulation executable and digitization procedure used in LHC Run3.</p>
<h2>Overview</h2>
<p>Detector simulation, the simulation of detector response from virtual particle events, consists of essentialy 2 parts: a) the generation of simple (energy deposit) traces in the detector due to the passage of particles and the interaction with the detector material. b) the conversion of those traces into (electronic) signals in the detector readout (usually called digitization).</p>
<p>The first part is handled by the <code>o2-sim</code> executable (See <a class="el" href="../../de/dc7/refdocDetectorSimulation.html#SimSection">SimSection</a>). The second part is handled in the <code>o2-sim-digitizer-workflow</code> executable (See <a class="el" href="../../de/dc7/refdocDetectorSimulation.html#DigitSection">DigitSection</a>). References to examples are <a class="el" href="../../de/dc7/refdocDetectorSimulation.html#Examples">collected here</a>.</p>
<h2>Key new features with respect to AliRoot</h2>
<p>The Run3 simulation offers the following features</p>
<ul>
<li><b>distributed system based on FairMQ</b> that is splitting event generation, particle transport and IO into separate asyncronous components that can be deployed on different machines</li>
<li><b>sub-event parallelism</b> making it possible to transport a single big event in a short time and to reduce memory consumption</li>
<li><b>parallelism</b> independent on transport engine</li>
<li><b>configuration via pre-defined parameter classes and ini/text files</b></li>
<li><b>clear separation of transport and digitization</b> - each phase can be run fully independently</li>
</ul>
<h1>Documentation of transport simulation <a class="anchor" id="SimSection"></a></h1>
<p>The purpose of the <code>o2-sim</code> executable is to simulate the passage of particles emerging from a collision inside the detector and to obtain their effect in terms of energy deposits (called hits) which could be converted into detectable signals. It is the driver executable which will spawn a topology of sub-processes that interact via messages in a distributed system.</p>
<h2>Usage overview</h2>
<ul>
<li><p class="startli"><b>Quick start example:</b> <a class="el" href="../../d2/d88/classA.html">A</a> typical (exemplary) invocation is of the form</p>
<div class="fragment"><div class="line">2-sim -n 10 -g pythia8pp -e TGeant4 -j 2 --skipModules ZDC,PHS</div>
</div><!-- fragment --><p class="startli">which would launch a simulation for 10 pythia8 events on the whole ALICE detector but ZDC and PHOS, using Geant4 on 2 parallel worker processes.</p>
</li>
<li><b>Generated output</b>: The simulation creates the following output files:</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">File   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>o2sim_Kine.root</code>   </td><td class="markdownTableBodyNone">contains kinematics information (primaries and secondaries) and event meta information    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>o2sim_geometry.root</code>   </td><td class="markdownTableBodyNone">contains the final <a class="el" href="../../d0/d10/namespaceROOT.html">ROOT</a> geometry created for simulation run    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>o2sim_grp.root</code>   </td><td class="markdownTableBodyNone">special global run parameters (grp) such as field    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>o2sim_XXXHits.root</code>   </td><td class="markdownTableBodyNone">hit file for each participating active detector XXX    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>o2sim_configuration.ini</code>   </td><td class="markdownTableBodyNone">summary of parameter values with which the simulation was done    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>o2sim_serverlog</code>   </td><td class="markdownTableBodyNone">log file produced from the particle generator server    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>o2sim_workerlog</code>   </td><td class="markdownTableBodyNone">log file produced form the transportation processes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>o2sim_hitmergerlog</code>   </td><td class="markdownTableBodyNone">log file produced from the IO process   </td></tr>
</table>
<ul>
<li><b>Main command line options</b>: The following major options are available (incomplete):</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Option   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-h,&ndash;help   </td><td class="markdownTableBodyNone">Prints the list of possible command line options and their default values.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">-n,&ndash;number   </td><td class="markdownTableBodyNone">The number of events to simulate.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-g,&ndash;generator   </td><td class="markdownTableBodyNone">name of a predefined generator template to use (such as pythia8pp, pythia8hi). Configuration of generations is explained in a dedicated section.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">-e,&ndash;engine   </td><td class="markdownTableBodyNone">Select the VMC transport engine (TGeant4, TGeant3).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-m,&ndash;modules   </td><td class="markdownTableBodyNone">List of modules/geometries to include (default is ALL); example -m PIPE ITS TPC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">-j,&ndash;nworkers   </td><td class="markdownTableBodyNone">Number of parallel simulation engine workers (default is half the number of hyperthread CPU cores)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">&ndash;chunkSize   </td><td class="markdownTableBodyNone">Size of a sub-event. This determines how many primary tracks will be sent to a simulation worker to process.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">&ndash;skipModules   </td><td class="markdownTableBodyNone">List of modules to skip / not to include (precedence over -m)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">&ndash;configFile   </td><td class="markdownTableBodyNone"><a class="el" href="../../d2/d88/classA.html">A</a> <code>.ini</code> file containing a list of (non-default) parameters to configure the simulation run. See section on configurable parameters for more details.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">&ndash;configKeyValues   </td><td class="markdownTableBodyNone">Like <code>--configFile</code> but allowing to set parameters on the command line as a string sequence. Example <code>--configKeyValues "Stack.pruneKine=false"</code>. Takes precedence over <code>--configFile</code>. <a class="el" href="../../db/dd7/structParameters.html">Parameters</a> need to be known ConfigurableParams.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">&ndash;seed   </td><td class="markdownTableBodyNone">The initial seed to (all) random number instances. Default is -1 which leads to random behaviour.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">-o,&ndash;outPrefix   </td><td class="markdownTableBodyNone">How output files should be prefixed. Default is o2sim. Example <code>-o mySignalProduction</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">&ndash;noGeant   </td><td class="markdownTableBodyNone">Switch off Geant transport. Just produce the generator kinematics.   </td></tr>
</table>
<ul>
<li><b>Expert control</b> via environment variables: <code>o2-sim</code> is sensitive to the following environment variables:</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Variable   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>ALICE_O2SIM_DUMPLOG</b>   </td><td class="markdownTableBodyNone">When set, the output of all FairMQ components will be shown on the screen and can be piped into a user logfile.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>ALICE_NOSIMSHM</b>   </td><td class="markdownTableBodyNone">When set, communication between simulation processes will not happen using a shared memory mechanism but using <a class="el" href="../../d0/d10/namespaceROOT.html">ROOT</a> serialization.   </td></tr>
</table>
<h2>Configurable <a class="el" href="../../db/dd7/structParameters.html">Parameters</a></h2>
<p>Simulation makes use of <code>configurable parameters</code> as described in the <a href="https://github.com/AliceO2Group/AliceO2/blob/dev/Common/SimConfig/doc/ConfigurableParam.md">ConfigurableParam.md</a> documentation. Detector code as well as general simulation code declare such parameter and access them during runtime. Once a parameter is declared, it can be influenced/set from the outside via configuration files or from the command line. See the <code>--configFile</code> as well as <code>--configKeyValues</code> command line options. The complete list of parameters and their default values can be inspected in the file <code>o2sim_configuration.ini</code> that is produced by an empty run <code>o2-sim -n 0 -m CAVE</code>.</p>
<p>Important parameters influencing the transport simulation are:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Main parameter key   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">G4   </td><td class="markdownTableBodyNone"><a class="el" href="../../db/dd7/structParameters.html">Parameters</a> influencing the Geant4 engine, such as the physics list. Example "G4.physicsmode=kFTFP_BERT_optical_biasing"    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Stack   </td><td class="markdownTableBodyNone"><a class="el" href="../../db/dd7/structParameters.html">Parameters</a> influencing the particle stack. Example include whether the stack does kinematics pruning or whether it keeps secondaries at all.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SimCutParams   </td><td class="markdownTableBodyNone"><a class="el" href="../../db/dd7/structParameters.html">Parameters</a> allowing to set some sime geometry stepping cuts in R, Z, etc.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Diamond   </td><td class="markdownTableBodyNone">Parameter allowing to set the interaction vertex location and the spread/width. Is used in all event generators.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Pythia8   </td><td class="markdownTableBodyNone"><a class="el" href="../../db/dd7/structParameters.html">Parameters</a> that influence the pythia8 generator.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">HepMC   </td><td class="markdownTableBodyNone"><a class="el" href="../../db/dd7/structParameters.html">Parameters</a> that influence the HepMC generator.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TriggerParticle   </td><td class="markdownTableBodyNone"><a class="el" href="../../db/dd7/structParameters.html">Parameters</a> influencing the trigger mechanism in particle generators.   </td></tr>
</table>
<p>Detectors may also have parameters influencing various pieces such geometry layout, material composition etc.</p>
<h2>Help on available generators</h2>
<p>Below some notes on example generators along with some usage info.</p>
<ul>
<li><b>Fwmugen</b></li>
</ul>
<p>fwmugen is a lightweight and simple “box” generator for forward muons (1 muon / event)</p>
<div class="fragment"><div class="line">o2-sim -m MFT -e TGeant3 -g fwmugen -n 10</div>
</div><!-- fragment --><ul>
<li><b>BoxGen</b></li>
</ul>
<div class="fragment"><div class="line">o2-sim -m PIPE ITS MFT -e TGeant3 -g boxgen -n 10 --configKeyValues &#39;BoxGun.pdg=13 ; BoxGun.eta[0]=-3.6 ; BoxGun.eta[1]=-2.45; BoxGun.number=100&#39;</div>
</div><!-- fragment --><p> This command line will generate 10 events with 100 forward muons.</p>
<ul>
<li><b>PYTHIA 8</b></li>
</ul>
<p>Configures pythia8 for min.bias pp collisions at 14 TeV</p>
<div class="fragment"><div class="line">o2-sim -m PIPE ITS MFT -g pythia8pp -n 50</div>
</div><!-- fragment --><p>[Describe in detail the environment variables]</p>
<h2>Data layout</h2>
<p>[Add something on data layout of hits file]</p>
<h2>F.A.Q.</h2>
<p>You may contribute to the documentation by asking a question</p>
<h4>1. <b>How can I interface an event generator from ALIROOT</b>?</h4>
<p>In order to access event generators from ALIROOT, such as <code>THijing</code> or <code>TPyhtia6</code>, you may use the <code>-g external</code> command line option followed by a <a class="el" href="../../d0/d10/namespaceROOT.html">ROOT</a> macro setting up the event generator. Examples thereof are available in the installation directory <code>$O2_ROOT/share/Generators/external</code>.</p>
<p>Users may write there own macros in order to customize to their needs.</p>
<h4>2. <b>How can I run on a subset of geometry modules</b>?</h4>
<p>Use the <code>--modules</code> or <code>-m</code> command line option. Example: <code>o2-sim -m PIPE ITS TPC</code> will run the simulation on a geometry/material consinsting of PIPE, ITS, TPC.</p>
<h4>3. <b>How can I run with exactly the same events as used in an AliRoot simulation?</b></h4>
<p>One may perform any arbitrary simulation with AliRoot and reuse the kinematics information in form of <code>Kinemtatics.root</code> produced. The file contains primary and possibly secondary particles (added by transportation). When the file is passed to <code>o2sim</code>, the primary particles my be used as the initial event. Use the **<code>-g extkin</code>** command line option: </p><div class="fragment"><div class="line">o2-sim -g extkin --extKinFile Kinematics.root ...</div>
</div><!-- fragment --><h4>4. <b>How can I generate events (signal) using the vertex position of already-generated (background) events?</b></h4>
<p>This process might be called embedding, where one wants to merge two events generated independenly. For that to be physically correct, both events have to originate from the same interaction vertex. Assuming that your already-generated (background) events are stored in the <code>o2sim.background.root</code> file, you can force the interaction vertex for the generation of a new set of events to be the same as the one in the background with the following command line option:</p>
<div class="fragment"><div class="line">o2-sim --embedIntoFile o2sim.background.root</div>
</div><!-- fragment --><p>Background events are sampled one-by-one until all events have been used. At that point the events start to be reused.</p>
<h4>5. <b>How can I obtain detailed stepping information?</b> <a class="anchor" id="MCStepLoggerSection"></a></h4>
<p>Run the simulation (currently only supported in combination with <code>o2-sim-serial</code>) with a preloaded library: </p><div class="fragment"><div class="line">MCSTEPLOG_TTREE=1 LD_PRELOAD=$MCSTEPLOGGER_ROOT/lib/libMCStepLoggerInterceptSteps.so o2-sim-serial -j 1 -n 10</div>
</div><!-- fragment --><p> This will produce a file <code>MCStepLoggerOutput.root</code> containing detailed information about steps and processes (where, what, ...). The file can be analysed using a special analysis framework. See <a href="https://github.com/AliceO2Group/VMCStepLogger/blob/master/README.md">https://github.com/AliceO2Group/VMCStepLogger/blob/master/README.md</a> for more documentation.</p>
<h4>6. <b>How can I add a trigger to the event generator?</b></h4>
<p>All event generator interfaces that comply with the <code><a class="el" href="../../d3/da7/classo2_1_1eventgen_1_1Generator.html">o2::eventgen::Generator</a></code> protocol can be triggered. <a class="el" href="../../d2/d88/classA.html">A</a> basic 'particle trigger' is implemented in the <code><a class="el" href="../../d8/d05/namespaceo2_1_1eventgen.html">o2::eventgen</a></code> core and allows the user to define a trigger particle. The definitions of the trigger particle can be expressed via command line arguments </p><div class="fragment"><div class="line">o2-sim -g pythia8pp -t particle --configKeyValues &quot;TriggerParticle.pdg=333;TriggerParticle.ptMin=5.;TriggerParticle.yMin=-0.5;TriggerParticle.yMax=0.5&quot;</div>
</div><!-- fragment --><p>Custom triggers can also be constructed by the user to provide unlimited flexibility in the trigger needs. An external trigger function can be specified via command line arguments </p><div class="fragment"><div class="line">o2-sim -g pythia8pp -t external --configKeyValues &#39;TriggerExternal.fileName=path_to_trigger_macro.C;TriggerExternal.funcName=&quot;the_function(some, parameters)&quot;&#39;</div>
</div><!-- fragment --><p> The function must comply with a simple protocol and return a lambda function defined as follows </p><div class="fragment"><div class="line">o2::eventgen::Trigger the_function()</div>
<div class="line">{</div>
<div class="line">  return [](const std::vector&lt;TParticle&gt;&amp; particles) -&gt; bool {</div>
<div class="line">    return true; // triggered</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Within the lambda function the user receives the stack of generated particles and can inspect it to define a trigger at will. The trigger is fired when the lambda function returns <code>true</code> and the simulation of the current event is subsequently started.</p>
<p>To allow users to define triggers that go beyond the particle stack generated by the event generator, another functionality is added. This allows the user to go deep into the core of the event generator, whenever this is possible. For this reason, this is called a 'DeepTrigger'. <a class="el" href="../../d2/d88/classA.html">A</a> 'DeepTrigger' is attached to the simulation in the same way as a normal trigger </p><div class="fragment"><div class="line">o2-sim -g pythia8pp -t external --configKeyValues &#39;TriggerExternal.fileName=path_to_deep_trigger_macro.C;TriggerExternal.funcName=&quot;the_deep_function(some, parameters)&quot;&#39;</div>
</div><!-- fragment --><p> In this case the function must comply with a similar, but different protocol than before and return a lambda function defined as follows </p><div class="fragment"><div class="line"> o2::eventgen::DeepTrigger the_deep_function()</div>
<div class="line">{</div>
<div class="line">  return [mpiMin](void* interface, std::string name) -&gt; bool {</div>
<div class="line">    return true;</div>
<div class="line">  };</div>
<div class="line">}</div>
</div><!-- fragment --><p> Notice that in this case the user is presented with a pointer to the event-generator interface and a string that defines its name. For the sake of generality, a <code>void*</code> has to be used in order to pass any possible types of event-generators, that are normally othogonal one to another. The name encodes a string to identify what generator has been passed and perform the correct cast to use it.</p>
<h4>7. <b>How can I change medium cut and process parameters on the fly?</b></h4>
<p>Some medium parameter definitions are defined in <code>$O2/Detectors/&lt;detector&gt;/simulation/data/simcuts.txt</code> (or in <code>$O2/Detectors/Passive/data/simcuts_&lt;modulename&gt;.txt</code> for passive modules), others might be hard-coded in the source code. To extract/change/study any of those parameters on the fly, it is possible to write out all of them into a <code>JSON</code> file with </p><div class="fragment"><div class="line">o2-sim &lt;args&gt; --configKeyValues &quot;MaterialManagerParam.outputFile=medium_params.json&quot;</div>
</div><!-- fragment --><p> <a class="el" href="../../db/dd7/structParameters.html">Parameters</a> of interest can be changed in <code>medium_params.json</code> and it can be passed <b>now as an input</b> for the target simulation with </p><div class="fragment"><div class="line">o2-sim &lt;args&gt; --configKeyValues &quot;MaterialManagerParam.inputFile=medium_params.json&quot;</div>
</div><!-- fragment --><p><b>Note</b> that process parameters have no effect when Geant4 is used for transport.</p>
<h3>Replaying steps and optimising full sim parameters</h3>
<p>The <code>MCReplay</code> engine can be used to replay a simulation based on steps logged by the <code>MCStepLogger</code> (see also a more <a href="https://github.com/AliceO2Group/VMCStepLogger/tree/v0.2.0/MCReplay">in-depth documentation</a>).</p>
<p>To run it with O2, first follow the steps as explained in <a class="el" href="../../de/dc7/refdocDetectorSimulation.html#MCStepLoggerSection">MCStepLoggerSection</a> to produce a file containing logged steps. To replay, do </p><div class="fragment"><div class="line">o2-sim-serial -n &lt;ref_nevents&gt; -e MCReplay -g extkinO2 --extKinFile o2sim_Kine.root -o replay</div>
</div><!-- fragment --><p> It is advisory to use another output prefix as done in this case since otherwise the hit files would be overwritten which might contain exactly the information one is interested in. Make sure to use/exclude the same modules as used in the reference run (<code>-m</code> and <code>--skipModules</code> flags). In case the reference run was done with another prefix, the kinematics file name is different, namely <code>&lt;prefix&gt;_Kine.root</code>.</p>
<p>If the name of the step log file is different, it can be passed with <code>--configKeyValues="MCReplayParam.stepFilename=&lt;path/step/file/name&gt;"</code>. It is also possible to set a minimum energy (in units of GeV) cut particles have to have when produced. For that, use <code>--configKeyValues="MCReplayParam.energyCut=0.1"</code> if everything produced below <code>0.1 GeV</code> should be dropped.</p>
<p>Comparing the produced hits with those from the reference run it is possible to omit steps/particle production which have a negligible impact on the hits and hence on digits. As a result, the detector simulation can be tuned to be faster and more efficient.</p>
<h3>Deep triggers</h3>
<p>Deep triggers is just a name to a new functionality that allows the user to define custom functions that will have a direct handle on the event generator interface. The functionality follows the schema of the previous point, with the user providing a custom lambda function that will receive from the framework a pointer to the internal event-generator interface object (i.e. for Pythia8, a pointer to the Pythia object) and a tagname to identify the interface. This functionality might be useful to users who want to provide triggers based on information beyond the stack of the generated particles, based on more internal counters/information in the event generator machinery.</p>
<p>Here is an example of a deep trigger implementation in Pythia8.</p>
<div class="fragment"><div class="line">//   usage: o2sim --trigger external --configKeyValues &#39;TriggerExternal.fileName=trigger_mpi.C;TriggerExternal.funcName=&quot;trigger_mpi()&quot;&#39;</div>
<div class="line"> </div>
<div class="line">#include &quot;Generators/Trigger.h&quot;</div>
<div class="line">#include &quot;Pythia8/Pythia.h&quot;</div>
<div class="line"> </div>
<div class="line">o2::eventgen::DeepTrigger</div>
<div class="line">  trigger_mpi(int mpiMin = 5)</div>
<div class="line">{</div>
<div class="line">  return [mpiMin](void* interface, std::string name) -&gt; bool {</div>
<div class="line">    if (!name.compare(&quot;pythia8&quot;)) {</div>
<div class="line">      auto py8 = reinterpret_cast&lt;Pythia8::Pythia*&gt;(interface);</div>
<div class="line">      return py8-&gt;info.nMPI() &gt;= mpiMin;</div>
<div class="line">    }</div>
<div class="line">    LOG(fatal) &lt;&lt; &quot;Cannot define MPI for generator interface \&#39;&quot; &lt;&lt; name &lt;&lt; &quot;\&#39;&quot;;</div>
<div class="line">    return false;</div>
<div class="line">  };</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Pythia8 UserHooks</h3>
<p>Pythia8 machinery allows the user to hook some code at various stages of the event-generation process. For details, please look at Pyhia8 manual. <a href="http://home.thep.lu.se/~torbjorn/pythia82html/UserHooks.html">http://home.thep.lu.se/~torbjorn/pythia82html/UserHooks.html</a></p>
<p>The interface is provided via a configuration macro, where the user will have to define a custom UserHooks according to the protocol defined by Pythia8. The macro will also have to provide a function to retrieve the pointer to the created custom UserHooks object.</p>
<p>This functionality might be of use for users who want to be able to steer the event-generation process from very deep inside the internal routines and want to veto some specific processes based on analysis of the status of Pythia8 at the various stages, i.e. veto events that do not have charm partons, before hadronisation of partons. This can save time in the event generation process as many steps can be skipped already at early time.</p>
<p>An example of a configuration macro is this one</p>
<div class="fragment"><div class="line">//   usage: o2sim -g pythia8pp --configKeyValues &quot;GeneratorPythia8.hooksFileName=pythia8_userhooks_charm.C&quot;</div>
<div class="line"> </div>
<div class="line">#include &quot;Generators/Trigger.h&quot;</div>
<div class="line">#include &quot;Pythia8/Pythia.h&quot;</div>
<div class="line"> </div>
<div class="line">class UserHooksCharm : public Pythia8::UserHooks</div>
<div class="line">{</div>
<div class="line"> public:</div>
<div class="line">  UserHooksCharm() = default;</div>
<div class="line">  ~UserHooksCharm() = default;</div>
<div class="line">  bool canVetoPartonLevel() override { return true; };</div>
<div class="line">  bool doVetoPartonLevel(const Pythia8::Event&amp; event) override</div>
<div class="line">  {</div>
<div class="line">    for (int ipa = 0; ipa &lt; event.size(); ++ipa) {</div>
<div class="line">      if (abs(event[ipa].id()) != 4)</div>
<div class="line">        continue;</div>
<div class="line">      if (fabs(event[ipa].y()) &gt; 1.5)</div>
<div class="line">        continue;</div>
<div class="line">      return false;</div>
<div class="line">    }</div>
<div class="line">    return true;</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">Pythia8::UserHooks*</div>
<div class="line">  pythia8_userhooks_charm()</div>
<div class="line">{</div>
<div class="line">  return new UserHooksCharm();</div>
</div><!-- fragment --><h2>Development</h2>
<h1>Documentation of the digitization step <a class="anchor" id="DigitSection"></a></h1>
<p>Digitization - the transformation of hits produced in the transport simulation to electronics detector output - is steered by the <code>o2-sim-digitizer-workflow</code> executable. The executable is implemented as a [DPL workflow] (<a href="https://github.com/AliceO2Group/AliceO2/blob/dev/Framework/Core/README.md">https://github.com/AliceO2Group/AliceO2/blob/dev/Framework/Core/README.md</a>). The main components in this workflow are:</p><ul>
<li><b><a class="el" href="../../d2/d88/classA.html">A</a> SimReader</b> process, responsible to analyze available simulation information/kinematics and to setup the digitization context, which describes things such as the structure of the timeframe (bunch cross properties and interaction rate) as well as how to combine different background and signal hits.</li>
<li><b>Digitizer processors</b> per detector, responsible for the actual digitization upon receiving the digitization context from the SimReader.</li>
<li><b>IO processors</b> per detector, responsible to write digits to files.</li>
<li><b>GRP updater</b>, a process to update the GRP file with information aquired in digitization.</li>
</ul>
<h2>Usage overview:</h2>
<ul>
<li><p class="startli"><b>Quick start example:</b> <a class="el" href="../../d2/d88/classA.html">A</a> minimal invocation is of the form</p>
<div class="fragment"><div class="line">2-sim-digitizer-workflow [--sims foo] -b</div>
</div><!-- fragment --><p class="startli">which would launch the digitization phase for all detectors that took part in a simulation stored under simulation prefix <code>foo</code> (default o2sim) and will digitize all events with a default bunch crossing structure. All digitizer will run in parallel to each other.</p>
</li>
<li><p class="startli"><b><a class="el" href="../../d2/d88/classA.html">A</a> more advanced example:</b></p>
<div class="fragment"><div class="line">2-sim-digitizer-workflow --sims bkg,sgn --interactionRate 1e6 --onlyDet TPC,ITS -b</div>
</div><!-- fragment --><p class="startli">which would launch the digitization phase for TPC and ITS with a custom LHC interactionRate. Moreover, this example does summation of digits coming from background (prefix bkg) as well as signal (prefix sgn) transport simulations.</p>
</li>
<li><b>Generated output</b>: The digitization process creates the following output files:</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">File   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>collisioncontext.root</code>   </td><td class="markdownTableBodyNone">Contains information about the collision/digitization context used in this digitization. Keeps the list of input files and how collisions were composed for the digits embedding process and time stamps where assigned.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>XXXdigits.root</code>   </td><td class="markdownTableBodyNone">Typically one digit file per detector XXX in a timeframe format. The file also typically contains mappings of digit indices to MC labels.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>o2simdigitizerworkflow_configuration.ini</code>   </td><td class="markdownTableBodyNone"><a class="el" href="../../d1/d4a/structSummary.html">Summary</a> of parameters used in the digitization process.   </td></tr>
</table>
<ul>
<li><b>Main command line options</b>: The following major options are available:</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Option   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-h,&ndash;help   </td><td class="markdownTableBodyNone">Prints the list of possible command line options and their default values.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">&ndash;sims   </td><td class="markdownTableBodyNone">Comma separated list of simulation prefixes that should be overlaid/embedded. Example <code>--sims background,signal</code> where <code>background</code> and <code>signal</code> refer to transport simulation productions. Final collisions will be composed from both of them (in a round robin fashion). See separate section about <a class="el" href="../../de/dc7/refdocDetectorSimulation.html#Embedding">Embedding</a> for more details. If just one prefix is given, normal digitization without overlay will be done.   </td></tr>
</table>
<p>| &ndash;tpc-lanes | Number of parallel digitizers for TPC, which has a special attention due an increased data rate compared to other detectors. | | | &ndash;interactionRate | Total hadronic interaction rate (Hz). | | &ndash;bcPatternFile | Interacting BC pattern file chaning the default bunch crossing pattern, see <code>macro/CreateBCPattern.C</code> for details. | | &ndash;onlyDet | Comma separated list of detectors to digitize. (Default is all) | | &ndash;skipDet | Comma separed list of detectors to exclude. | | &ndash;incontext | Name of context file. Useful for reusing a context from a previous run when we split the processing detectorwise. | | &ndash;outcontext | Specify name of contextfile to produce. | | &ndash;simFileQED | Optional special QED hit file to include effect from QED effects into digitization. |</p>
<h2>Interaction sampling <a class="anchor" id="Interaction sampling"></a></h2>
<p>The files produced by the <code>o2-sim</code> contain only a set of separate events, w/o any time stamp. The digitization will sample the vector of non-decreasing <code>{BC/orbit}</code> pairs according to bunch filling schema and requested interaction rate and provide it to digitizers. The interaction sampling is steered by the <code>HBFUtils</code> configurable parameters, e.g.</p>
<div class="fragment"><div class="line">2-sim-digitizer-workflow --configKeyValues &quot;HBFUtils.nHBFPerTF=128;HBFUtils.orbitFirst=123;HBFUtils.orbitFirstSampled=300&quot;</div>
</div><!-- fragment --><p>The most important here is <code>HBFUtils.orbitFirstSampled</code> which tells to <code>InteractionSampler</code> the orbit from which the sampling should start. Other parameters, <code>nHBFPerTF</code> and <code>orbitFirst</code> do not directly affect the digitization but they are stored in the <code>grp</code> object (<code>o2sim_grp.root</code> file) and the number of orbits per <a class="el" href="../../d5/d14/structTF.html">TF</a> and the 1st orbit of the run. The full content of the <code>HBFUtils</code> is stored in the <code>o2simdigitizerworkflow_configuration.ini</code> and can be used in reconstruction and MC-&gt;raw-data creation processes. Particularly, when creating the raw data (see <code>...-digi2raw</code> group of commands in <code>O2/prodtests/full_system_test.sh</code>) the content of the <code>HBFUtils</code> settings will be loaded from this ini file (the name can be changed via <code>--hbfutils-config &lt;ini-file&gt;</code> option) and <code>HBFUtils.orbitFirst</code> will be used to define the start-of-the-run (<code>SOX flag in the RDH</code>) and <code>HBFUtils.nHBFPerTF</code> will be used to chop the digitized data to TFs. Note that for the detectors in continuous readout mode all empty HBFs will be created for all orbits w/o detector data between the <code>SOX</code> and the last orbit of the <a class="el" href="../../d5/d14/structTF.html">TF</a> for which data was received. In case you want to create raw data starting from the 1st sampled <a class="el" href="../../d5/d14/structTF.html">TF</a>, you should override the <code>HBFUtils.orbitFirst</code> by the wanted orbit, i.e. for the digitization done as in the example above one can request</p>
<div class="fragment"><div class="line">2-ft0-digi2raw --configKeyValues &quot;HBFUtils.orbitFirst=251&quot; ...</div>
</div><!-- fragment --><p>to start the raw data not from the orbit 123 indicated during digitization but from the orbit 251 (i.e. the 2nd <a class="el" href="../../d5/d14/structTF.html">TF</a> of the run). Additional setting <code>HBFUtils.maxNOrbits</code> can be provided to limit the number of orbits stored (counted from the <code>SOX</code>) in the raw data (i.e. all data with <code>orbit &gt; HBFUtils.orbitFirst + HBFUtils.maxNOrbits</code> will be ignored when creating the raw data.</p>
<p>Similarly, when running the reconstruction workflow using the output of the digitization, the <code>HBFUtils</code> settings used by <code>o2-sim-digitizer-workflow</code> will be loaded (again, they can be overridden by either providing <code>--hbfutils-config &lt;ini-file&gt;</code> option or by explicit <code>--configKeyValues "HBFUtils...&lt;/tt&gt; setting) and the DPL will make sure that the content of the &lt;tt&gt;DataHeader.firstTForbit&lt;/tt&gt; correspond
to the 1st orbit of the TF containing &lt;tt&gt;HBFUtils.orbitFirstSampled&lt;/tt&gt; (then incremented by &lt;tt&gt;HBFUtils.nHBFPerTF&lt;/tt&gt; for the following TFs if the digits files contain multiple TF entries).

&lt;h2&gt;Embedding @anchor Embedding &lt;a&gt;&lt;/a&gt;&lt;/h2&gt;


&lt;h2&gt;Monte Carlo Labels @anchor MCLabels &lt;a&gt;&lt;/a&gt;&lt;/h2&gt;

We can associate digits to tracks/particles of the original transport simulation, so as to keep provenance information of how
digits were triggered. This information can be passed forward to reconstruction and analysis and used to study reconstruction efficiencies etc.

To this end, a special data object &lt;tt&gt;MCCompLabel&lt;/tt&gt; is offered, which allows to encapsulate the identifiers of track, event and source kinematics files. 
@icode{cpp} 
  MCCompLabel(int trackID, int evID, int srcID, bool fake = false)
@endicode 
This information should be enough to lookup and load the precise Monte Carlo track (@ref "MCReader" "see here").

Association of digits to an arbitrary number of labels is done via filling a &lt;strong&gt;separate&lt;/strong&gt; and &lt;strong&gt;dedicated&lt;/strong&gt; container called &lt;tt&gt;MCTruthContainer&lt;/tt&gt; which is written as a separate branch to the output file, next to the branch for digits. This has the advantage that digits may be kept as close as possible to the raw data and we can have arbitrary number of labels at a minimal memory cost.

The mechanics is as follows: For a collection of digits created for detector &lt;tt&gt;foo&lt;/tt&gt;
@icode{cpp} 
std::vector&lt;o2::foo::Digits&gt; mDigits;
@endicode 
we keep a separate container of labels of type:
@icode{cpp} 
o2::dataformats::MCTruthContainer&lt;o2::dataformats::MCCompLabel&gt; mLabelContainer;
@endicode 
Querying the labels works by positional correspondance: Labels for the digit at position &lt;tt&gt;pos&lt;/tt&gt; can be accessed in the following way:
@icode{cpp} 
const auto&amp; digit = mDigits[pos];
// returns an iterable view of labels
const auto&amp; labels_for_digit = mLabelContainer.getLabels(pos);
// iterate over labels
for (auto&amp; label : labels_for_digit) {
   // process label
}
@endicode 

If positional correspondance is too weak, one may eventualy choose to record the corresponding data index in the labelcontainer inside the digit itself:
@icode{cpp} 
const auto&amp; digit = mDigits[pos];
// returns an iterable view of labels
const auto&amp; labels_for_digit = mLabelContainer.getLabels(digit.labelindex);
// iterate over labels
for (auto&amp; label : labels_for_digit) {
   // process label
}
@endicode 


&lt;h2&gt;Accessing Monte Carlo kinematics@anchor MCReader &lt;a&gt;&lt;/a&gt;&lt;/h2&gt;

After digitization is done, one can use the &lt;tt&gt;MCKinematicsReader&lt;/tt&gt; class to load and access the Monte Carlo tracks.
The MCKinematicsReader needs the digitization context file, generated during digitization. Once initialized it can return the tracks associated to a Monte Carlo label.

A typical code example may be
@icode{cpp} 
// init the reader from the context
o2::steer::MCKinematicsReader reader("collisioncontext.root");

// load digits from the digits file --&gt; save in alldigits
// load the label container from the digits file --&gt; save in labelcontainer

// this is simply iterating over all the digits and querying the tracks that contributed to these digits

for (int pos = 0; pos &lt; alldigits.size(); ++pos) {
  const auto&amp; digit = alldigits[pos];
  const auto&amp; labels_for_digit = labelcontainer.getLabels(pos);
  // iterate over labels
  for (auto&amp; label : labels_for_digit) {
     track = reader.getTrack(label);
     // do something with the track
  }
}
@endicode 
Note, that one can also access kinematics directly after the transport simulation. 
In this case, one needs to initialize the MCKinematicsReader in a different mode:
@icode{cpp} 
// init the reader from the transport kinematics file (assuming here prefix o2sim)
o2::steer::MCKinematicsReader reader("o2sim", o2::steer::MCKinematicsReader::Mode::kMCKine);

// loop over all events in the file
for (int event = 0; event &lt; reader.getNEvents(0); ++event) {
  // get all Monte Carlo tracks for this event
  std::vector&lt;MCTrack&gt; const&amp; tracks = reader.getTracks(event);

  // analyse tracks
}
@endicode 


&lt;h1&gt;Simulation tutorials/examples @anchor Examples &lt;a&gt;&lt;/a&gt;&lt;/h1&gt;

Some examples for the usage of simulation and digitization are collected in an &lt;a href="../run/SimExamples" &gt;examples folder&lt;/a&gt;.
Other helpful resources are the scripts used for regression testing in &lt;a href="../prodtests" &gt;prodtests&lt;/a&gt;. 

&lt;table class="markdownTable"&gt;
  &lt;tr class="markdownTableHead"&gt;    &lt;th class="markdownTableHeadNone"&gt; Example   </code></p>
<p><code> Short Description    </code></p>
<p><code> </code></p>
<p><code> <a href="../../../run/SimExamples/HF_Embedding_Pythia8">HF_Embedding_Pythia8</a>   </code></p>
<p><code> Example showing how to setup a complex HF simulation for embedding    </code></p>
<p><code> </code></p>
<p><code> <a href="../../../run/SimExamples/AliRoot_Hijing">AliRoot_Hijing</a>   </code></p>
<p><code> Example showing how to use Hijing from AliRoot for event generation    </code></p>
<p><code> </code></p>
<p><code> <a href="../../../run/SimExamples/AliRoot_AMPT">AliRoot_AMPT</a>   </code></p>
<p><code> Example showing how to use AMPT from AliRoot for event generation    </code></p>
<p><code> </code></p>
<p><code> <a href="../../../run/SimExamples/Adaptive_Pythia8">Adaptive_Pythia8</a>   </code></p>
<p><code> Complex example showing <b>generator configuration for embedding</b> that cat adapt the response based on the background event    </code></p>
<p><code> </code></p>
<p><code> <a href="../../../run/SimExamples/Signal_ImpactB">Signal_ImpactB</a>   </code></p>
<p><code> Example showing <b>generator configuration for embedding</b> that cat adapt to the impact parameter of the background event    </code></p>
<p><code> </code></p>
<p><code> <a href="../../../run/SimExamples/JustPrimaryKinematics">PrimaryKinematics</a>   </code></p>
<p><code> Example showing how to obtain only primary kinematics via transport configuration    </code></p>
<p><code> </code></p>
<p><code> <a href="../../../run/SimExamples/HepMC_STARlight">HepMC_STARlight</a>   </code></p>
<p><code> Simple example showing <b>generator configuration</b> that runs a standalone <code>STARlight</code> generation that couples to the <code><a class="el" href="../../d4/d7c/namespaceo2.html" title="a couple of static helper functions to create timestamp values for CCDB queries or override obsolete ...">o2</a></code> via a <code>HepMC</code> file    </code></p>
<p><code> </code></p>
<p><code> <a href="../../../run/SimExamples/Jet_Embedding_Pythia8">Jet_Embedding_Pythia</a>   </code></p>
<p><code> Complex example showing <b>generator configuration</b>, <b>digitization embedding</b>, <b>MCTrack access</b>    </code></p>
<p><code> </code></p>
<p><code> <a href="../../../run/SimExamples/Selective_Transport">Selective_Transport</a>   </code></p>
<p><code> Simple example showing how to run simulation transporting only a custumisable set of particles    </code></p>
<p><code> </code></p>
<p><code> <a href="../../../run/SimExamples/Selective_Transport_pi0">Selective_Transport_pi0</a>   </code></p>
<p><code> Complex example showing how to run simulation within the inhibit-pause-trigger-continue approach    </code></p>
<p><code> </code></p>
<p><code> <a href="../../../run/SimExamples/Custom_EventInfo">Custom_EventInfo</a>   </code></p>
<p><code> Simple example showing how to add custom information to the MC event header    </code></p>
<p><code> </code></p>
<p><code> <a href="../../../prodtests/sim_challenge.sh">sim_challenge.sh</a>   </code></p>
<p><code> Basic example doing a <b>simple transport, digitization, reconstruction pipeline</b> on the full dectector. All stages use parallelism.    </code></p>
<p><code> </code></p>
<p><code> <a href="../../../prodtests/sim_performance_test.sh">sim_performance.sh</a>   </code></p>
<p><code> Basic example for serial transport and linearized digitization sequence (one detector after the other). Serves as standard performance candle.   </code></p>
<p><code> </code></p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d7/d16/refdoc.html">Documentation pages</a></li>
    <li class="footer">Generated on Sat Feb 21 2026 17:59:16 for Project by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
