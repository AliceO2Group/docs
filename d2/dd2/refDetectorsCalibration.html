<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Project: Detectors Calibration</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../o2_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d2/dd2/refDetectorsCalibration.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Detectors Calibration</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Time-interval based calibration flow for O2</h1>
<p>The calibration flow of O2 foresees that all calibration devices are running on dedicated EPN calibration nodes. These nodes are also called aggregator nodes. <a class="el" href="../../d2/d88/classA.html">A</a> particular calibration device can only run on a single calibration node, as it is supposed to receive the complete input data from each EPN processing node. The processing nodes can send the data either for every <a class="el" href="../../d5/d14/structTF.html">TF</a> or sporadically. In the latter case for example accumulated for every 10 TFs. In both cases the calibration input reaches the calibration nodes asynchronously. And since there are up to 250 EPNs processing TFs in two different NUMA domains, TFs which reach the calibration node consecutively might in reality be 500 TFs apart in absolute time. This is because the processing time of individual TFs can vary quite significantly. The calibration devices have to prepare the calibration objects for time intervals (TimeSlots) which are defined by the user. They have a specificied duration and a minimum statistics requirement. For example a calibration is supposed to aggregate data for 10 minutes and for a meaningful calibration within these 10 minutes a certain amount of global tracks is required. In case after 10 minutes the amount of global tracks is not sufficient, the framework can automatically increase the interval of 10 minutes until enough global tracks are available to create the calibration object.</p>
<h2>TimeSlotCalibration&lt;Container&gt;</h2>
<p>Each calibration device which is supposed to run on the aggregator should derive from <code><a class="el" href="../../d7/d9d/classo2_1_1calibration_1_1TimeSlotCalibration.html">o2::calibration::TimeSlotCalibration</a>&lt;Container&gt;</code>. It is a templated class. The <code>Container</code> type is the object in which the calibration data per TimeSlot will be accumulated.</p>
<h3>Configuration of the TimeSlot</h3>
<p>Internally the default length of a TimeSlot is calculated in number of TFs. The default <a class="el" href="../../d5/d14/structTF.html">TF</a> length is 128 orbits, but theoretically this can change. Therefore it is advised to set the TimeSlot length via the methods <code>setSlotLengthInSeconds(int s)</code> or <code>setSlotLengthInOrbits(int n)</code>, which will be internally converted (and rounded) to the corresponding number of TFs at the 1st <a class="el" href="../../d5/d14/structTF.html">TF</a> processing. At that time we know the <a class="el" href="../../d5/d14/structTF.html">TF</a> length from the GRPECS object. One can also set the number of TFs per slot directly via <code>setSlotLength(o2::calibration::TFType n)</code>. With <code>setSlotLength(o2::calibration::INFINITE_TF)</code> there will be only 1 slot at a time, valid till infinity. <a class="el" href="../../d2/d88/classA.html">A</a> special mode is configured with <code>setSlotLength(0)</code> in which case there will only be a single slot, w/o explicit boundaries which is filled until the statistics is reached. In case <code>setSlotLength(0)</code> is configured we can also use <code>setCheckIntervalInfiniteSlot(o2::calibration::TFType updateInterval)</code> in which case the calibration checks whether the statistics is sufficient only after <code>updateInterval</code> TFs. Otherwise it would check after every <a class="el" href="../../d5/d14/structTF.html">TF</a>.</p>
<p>The TFs arrive asynchronously at the aggregator node. The <code>TimeSlotCalibration</code> keeps a <code>std::deque</code> of TimeSlots for which it aggregates the input data simultaneously. Whenever a slot has reached its configured duration the statistics requirement is checked. In case it is not fulfilled, the slot can be extended or merged to the previous slot in order to obtain the required statistics.</p>
<p>By default, TFs which arrive more than <code>3 * SlotLengthInTF</code> later than the most recent <a class="el" href="../../d5/d14/structTF.html">TF</a> processed are discarded. This maximum delay can be configured via <code>setMaxSlotsDelay(int nSlots)</code>. If it is set to 4 and each slot has the length of 30 TFs, then upon processing of <a class="el" href="../../d5/d14/structTF.html">TF</a> 121 the input from TF0 would be discarded, if it was not already processed.</p>
<p>In order to prepare only one CCDB object at the end of the run you can use <code>setUpdateAtTheEndOfRunOnly()</code>. In this case all the above settings for the slot duration are irrelevant. And upon the <code>endOfStream</code> of your calibration device you should make a call to <code>checkSlotsToFinalize()</code>.</p>
<h3>Mandatory methods to implement when deriving from <code><a class="el" href="../../d7/d9d/classo2_1_1calibration_1_1TimeSlotCalibration.html">o2::calibration::TimeSlotCalibration</a>&lt;Container&gt;</code></h3>
<ul>
<li><code>void initOutput()</code>: initialization of the output object (typically a vector of calibration objects and another one with the associated CcdbObjectInfo);</li>
<li><code>bool hasEnoughData(const <a class="el" href="../../d8/df5/classo2_1_1calibration_1_1TimeSlot.html">o2::calibration::TimeSlot</a>&lt;Container&gt;&amp; slot)</code> : method to determine whether a TimeSlot has enough data to be calibrated; if not, it will be merged to the following (in time) one;</li>
<li><code>void finalizeSlot(<a class="el" href="../../d8/df5/classo2_1_1calibration_1_1TimeSlot.html">o2::calibration::TimeSlot</a>&lt;Container&gt;&amp; slot)</code> : method to process the calibration data accumulated in each TimeSlot;</li>
<li><code><a class="el" href="../../d8/df5/classo2_1_1calibration_1_1TimeSlot.html">o2::calibration::TimeSlot</a>&lt;Container&gt;&amp; slot emplaceNewSlot(bool front, TFType tstart, TFType tend)</code> : method to creata a new TimeSlot; this is specific to the calibration procedure as it instantiates the detector-calibration-specific object.</li>
</ul>
<p>See e.g. <a class="el" href="../../da/d2b/LHCClockCalibrator_8h.html">LHCClockCalibrator.h</a>/cxx in <a class="el" href="../../da/d2b/LHCClockCalibrator_8h.html">AliceO2/Detectors/TOF/calibration/include/TOFCalibration/LHCClockCalibrator.h</a> and AliceO2/Detectors/TOF/calibration/srcLHCClockCalibrator.cxx</p>
<p>Sometimes it might be useful to define the 1st slot of the run shorter than the nominal slot length, e.g. to not rely to long on the previous run or default calibration. In this case one can impose to the calibration class an offset using method <code>setStartOffsetFrac(float offset)</code>, where <code>offset</code> is a fractional of the nominal slot length to be subtracted from the nominal boundaries of all slots (except the very 1st one, whose startTF is set to 0). The fractional offset should be in <code>[0:0.95)</code> range, any value outside this range will be overridden to the nearest boundary. This feature is supported only for the finite slot-length calibrations. E.g. if the nominal slot length is 10 minutes <code>(==~210000 TFs)</code>, setting <code>setStartOffsetFrac(float 0.7)</code> will lead to 1st slot finalized after the first 3 minutes, while the rest of the slots will be defined with nominal 10 minutes coverage. If statistics of this 1st short slot is insufficient, it will be merged as usual with the next slot (note this if this happens, in the example above the 1st calibration will be available in 13 minutes...).</p>
<h2>TimeSlot&lt;Container&gt;</h2>
<p>The TimeSlot is a templated class which takes as input type the Container that will hold the calibration data needed to produce the calibration objects (histograms, vectors, array...). Each calibration device could implement its own Container, according to its needs.</p>
<p>The Container class needs to implement the following methods:</p>
<ul>
<li><code>void merge(const Container* prev)</code> : method to allow merging of the content of a TimeSlot to the content of the following one, when stastics is limited.</li>
<li><code>void <a class="el" href="../../dc/da7/test__ctf__io__cpv_8cxx.html#a6d259de15de2178d0428c0d2251f3dd8">print()</a></code> : method to print the content of the Container</li>
<li><code>void fill(DATA data, ...)</code> : method to decide how to use the calibration data within the container (e.g. fill a vector). The type of <code>DATA</code> is usually <code>const gsl::span&lt;your-input-data&gt;</code>, but can also be anything else. Optionally the <code>fill</code> method can accept additional input of arbitrary type;</li>
</ul>
<p>or, alternatively</p>
<ul>
<li><code>void fill(<a class="el" href="../../de/d0f/structo2_1_1dataformats_1_1TFIDInfo.html">o2::dataformats::TFIDInfo</a>&amp; ti, DATA data, ...)</code> : method to decide how to use the calibration data within the container (e.g. fill a vector) and having access to the TFIDInfo struct providing relevant info for current <a class="el" href="../../d5/d14/structTF.html">TF</a> (tfCounter, runNumber, creationTime etc.). If provided, this latter method will be used.</li>
</ul>
<p>See e.g. <a class="el" href="../../da/d2b/LHCClockCalibrator_8h.html">LHCClockCalibrator.h</a>/cxx in <a class="el" href="../../da/d2b/LHCClockCalibrator_8h.html">AliceO2/Detectors/TOF/calibration/include/TOFCalibration/LHCClockCalibrator.h</a> and AliceO2/Detectors/TOF/calibration/srcLHCClockCalibrator.cxx</p>
<p>The Slot provides a generic methods to access its boundaries: <code>getTFStart()</code> and <code>getTFEnd()</code> in terms of <a class="el" href="../../d5/d14/structTF.html">TF</a> counter (as assigned by the DataDistribution) and <code>getStartTimeMS()</code>, <code>getEndTimeMS()</code> for the absolute time stamp in milleseconds.</p>
<h2>detector-specific-calibrator-workflow</h2>
<p>Each calibration will need to be implemented in the form of a workflow, whose options should include those for the calibration device itself (for example the slot length and statistics requirement). The output to be sent by the calibrator should include:</p>
<ul>
<li>a vector of the snapshots of the object to be put in the CCDB;</li>
<li>a vector of the <code><a class="el" href="../../d7/deb/classo2_1_1ccdb_1_1CcdbObjectInfo.html">o2::ccdb::CcdbObjectInfo</a></code> objects that contain the extra information (metadata, startValidity...) associated to the objects themselves.</li>
</ul>
<p>The origins of the pair of outputs will always be <code><a class="el" href="../../d1/d7c/structo2_1_1calibration_1_1Utils.html#ab2cb9854f082bd4de5d4fe1713aca54e">o2::calibration::Utils::gDataOriginCDBPayload</a></code> and <code><a class="el" href="../../d1/d7c/structo2_1_1calibration_1_1Utils.html#a5c4ff30ab8d6ec063a40021bbd946bbf">o2::calibration::Utils::gDataOriginCDBWrapper</a></code> respectively, while the DataDescription must be unique for given calibration type, e.g.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="../../d0/d3e/MCH_2Raw_2Tools_2rawdump_8cxx.html#a7dc04e2458e5499a252d97256c6ec944">output</a>.snapshot(Output{<a class="code hl_variable" href="../../d1/d7c/structo2_1_1calibration_1_1Utils.html#ab2cb9854f082bd4de5d4fe1713aca54e">o2::calibration::Utils::gDataOriginCDBPayload</a>, <span class="stringliteral">&quot;TOF_LHCphase&quot;</span>, <a class="code hl_variable" href="../../dd/d0b/GPUCommonAlgorithm_8h.html#ad9484f5522d0e5f033037c369365ec61">i</a>}, *<a class="code hl_typedef" href="../../dc/da3/glcorearb_8h.html#a0a221b005894579fea3b9eb7bfc2ee71">image</a>.get()); <span class="comment">// vector&lt;char&gt;</span></div>
<div class="line"><a class="code hl_function" href="../../d0/d3e/MCH_2Raw_2Tools_2rawdump_8cxx.html#a7dc04e2458e5499a252d97256c6ec944">output</a>.snapshot(Output{<a class="code hl_variable" href="../../d1/d7c/structo2_1_1calibration_1_1Utils.html#a5c4ff30ab8d6ec063a40021bbd946bbf">o2::calibration::Utils::gDataOriginCDBWrapper</a>, <span class="stringliteral">&quot;TOF_LHCphase&quot;</span>, <a class="code hl_variable" href="../../dd/d0b/GPUCommonAlgorithm_8h.html#ad9484f5522d0e5f033037c369365ec61">i</a>}, <a class="code hl_typedef" href="../../dc/da3/glcorearb_8h.html#adb12a0d439f32ca388b2c806150cc54d">w</a>);            <span class="comment">// root-serialized</span></div>
<div class="ttc" id="aGPUCommonAlgorithm_8h_html_ad9484f5522d0e5f033037c369365ec61"><div class="ttname"><a href="../../dd/d0b/GPUCommonAlgorithm_8h.html#ad9484f5522d0e5f033037c369365ec61">i</a></div><div class="ttdeci">int32_t i</div><div class="ttdef"><b>Definition</b> <a href="../../dd/d0b/GPUCommonAlgorithm_8h_source.html#l00435">GPUCommonAlgorithm.h:436</a></div></div>
<div class="ttc" id="aMCH_2Raw_2Tools_2rawdump_8cxx_html_a7dc04e2458e5499a252d97256c6ec944"><div class="ttname"><a href="../../d0/d3e/MCH_2Raw_2Tools_2rawdump_8cxx.html#a7dc04e2458e5499a252d97256c6ec944">output</a></div><div class="ttdeci">void output(const std::map&lt; std::string, ChannelStat &gt; &amp;channels)</div><div class="ttdef"><b>Definition</b> <a href="../../d0/d3e/MCH_2Raw_2Tools_2rawdump_8cxx_source.html#l00197">rawdump.cxx:197</a></div></div>
<div class="ttc" id="aglcorearb_8h_html_a0a221b005894579fea3b9eb7bfc2ee71"><div class="ttname"><a href="../../dc/da3/glcorearb_8h.html#a0a221b005894579fea3b9eb7bfc2ee71">image</a></div><div class="ttdeci">GLeglImageOES image</div><div class="ttdef"><b>Definition</b> <a href="../../dc/da3/glcorearb_8h_source.html#l04021">glcorearb.h:4021</a></div></div>
<div class="ttc" id="aglcorearb_8h_html_adb12a0d439f32ca388b2c806150cc54d"><div class="ttname"><a href="../../dc/da3/glcorearb_8h.html#adb12a0d439f32ca388b2c806150cc54d">w</a></div><div class="ttdeci">GLubyte GLubyte GLubyte GLubyte w</div><div class="ttdef"><b>Definition</b> <a href="../../dc/da3/glcorearb_8h_source.html#l00852">glcorearb.h:852</a></div></div>
<div class="ttc" id="astructo2_1_1calibration_1_1Utils_html_a5c4ff30ab8d6ec063a40021bbd946bbf"><div class="ttname"><a href="../../d1/d7c/structo2_1_1calibration_1_1Utils.html#a5c4ff30ab8d6ec063a40021bbd946bbf">o2::calibration::Utils::gDataOriginCDBWrapper</a></div><div class="ttdeci">static constexpr o2::header::DataOrigin gDataOriginCDBWrapper</div><div class="ttdef"><b>Definition</b> <a href="../../d3/de0/Detectors_2Calibration_2include_2DetectorsCalibration_2Utils_8h_source.html#l00044">Utils.h:44</a></div></div>
<div class="ttc" id="astructo2_1_1calibration_1_1Utils_html_ab2cb9854f082bd4de5d4fe1713aca54e"><div class="ttname"><a href="../../d1/d7c/structo2_1_1calibration_1_1Utils.html#ab2cb9854f082bd4de5d4fe1713aca54e">o2::calibration::Utils::gDataOriginCDBPayload</a></div><div class="ttdeci">static constexpr o2::header::DataOrigin gDataOriginCDBPayload</div><div class="ttdef"><b>Definition</b> <a href="../../d3/de0/Detectors_2Calibration_2include_2DetectorsCalibration_2Utils_8h_source.html#l00043">Utils.h:43</a></div></div>
</div><!-- fragment --><p>Note that in order to access the absolute time of the slot boundaries, one should subscribe to CTP orbit reset time object (at least) via GRPGeomHelper class.</p>
<p>See e.g. <a class="el" href="../../d0/d37/LHCClockCalibratorSpec_8h.html" title="Device to calibrate LHC clock phase using TOF data.">AliceO2/Detectors/TOF/calibration/testWorkflow/LHCClockCalibratorSpec.h</a>, <a class="el" href="../../d1/d1b/lhc-clockphase-workflow_8cxx.html">AliceO2/Detectors/TOF/calibration/testWorkflow/lhc-clockphase-workflow.cxx</a></p>
<h2>Integration of calibration workflows into the global framework</h2>
<p>For the synchronous processing on the EPN the calibration workflows are grouped according to their origin (BARREL, CALO, MUON and FORWARD) and to the nature of their input (<a class="el" href="../../d5/d14/structTF.html">TF</a> for devices expecting input for every <a class="el" href="../../d5/d14/structTF.html">TF</a> and SPORADIC for devices expecting input sporadically). For each group (e.g. <code>BARREL_TF</code>) a pair of <code>o2-dpl-output-proxy</code> running on the processing EPNs and <code>o2-dpl-raw-proxy</code> running on the calibration nodes is initialized and these proxys are used to transfer the input from processing nodes to the calibration node. Have a look at the <code>DATA/common/setenv_calib.sh</code> script in O2DPG where for each calibration the required data descriptors are added to the proxies. In addition there is always some logic to decide whether a specific calibration should be enabled or not.</p>
<p>The workflow which is running on the processing nodes should be added in the <code>prodtests/full-system-test/calib-workflow.sh</code> script. The workflow running on the aggregator should be added to <code>prodtests/full-system-test/aggregator-workflow.sh</code>.</p>
<h2>Calibrating over multiple runs</h2>
<p>Some statistics-hungry calibrations define single time-slot which integrates data of the whole run. If there is a possibility that for the short run the slot will not accumulate enough statistics, one can save the user-defined content of the slot to a file in the dedicated partition on the calibrator node and adopt data from this file in the next run. In order to do that the calibrator class derived from the TimeSlotCalibration must:</p>
<ul>
<li>set fixed file name to write via <code>setSaveFileName(const std::string&amp; n)</code> method. Also, the corresponding workflow should provide/parse an option to set the output directory.</li>
<li>implement virtual method <code>bool saveLastSlotData(TFile&amp; fl)</code> which writes content of the (last and only) slot into the provided file handler. It is up to detector to define the format of the stored data. The framework will write to the same file a TimeSlotMetaData struct describing the start/end timestamps and start/end runs for the data written.</li>
<li>implement virtual method <code>bool adoptSavedData(const TimeSlotMetaData&amp; metadata, TFile&amp; fl)</code> which reads and adds saved data to the slot in the new run. Provided metadata should be used to judge if the saved data are useful.</li>
<li>decide e.g. in the finalizeSlot method if the slot content must be saved to be accounted in the following run and call <code>saveLastSlot()</code> in that case.</li>
<li>in the beginning of the processing, e.g. after the 1st call of the <code>process(..)</code> method (where the time-slot will be created) call <code>loadSavedSlot()</code> method, i.e. <div class="fragment"><div class="line">auto data = pc.inputs().get&lt;...&gt;; // get input data</div>
<div class="line">o2::base::TFIDInfoHelper::fillTFIDInfo(pc, mCalibrator-&gt;getCurrentTFInfo());</div>
<div class="line">mCalibrator-&gt;process(data);</div>
<div class="line">static bool firstCall = true;</div>
<div class="line">if (firstCall &amp;&amp; getNSlots()) {</div>
<div class="line">  firstCall = false;</div>
<div class="line">  loadSavedSlot();</div>
<div class="line">}</div>
</div><!-- fragment --> Make sure the static method <code><a class="el" href="../../de/d72/structo2_1_1base_1_1TFIDInfoHelper.html#a872cf8cb05f76e1dc789b320f2df6346">o2::base::TFIDInfoHelper::fillTFIDInfo</a>(pc, mCalibrator-&gt;getCurrentTFInfo());</code> was called from the <code>run()</code> method before the <code><a class="el" href="../../d8/d20/structprocess.html">process(...)</a></code> call.</li>
</ul>
<p>The slot saving and loading will be done only if <code>setSavedSlotAllowed(true)</code> was called explicitly from the calibrator device before the processing starts (e.g. in the <code>init()</code> method). Since one can have multiple instances of the calibrator device running at the same time (in staging and produnction partitions, synthetic and real runs) it is important to make sure that this method is called only for the physics run calibration.</p>
<p>In order to not pollute calibration node disk, the file will be removed in the end of <code>loadSavedSlot()</code> call.</p>
<h2>ccdb-populator-workflow</h2>
<p>This is the workflow that, connected to all workflows producting calibrations with different granularities and frequencies, will update the CCDB.</p>
<p>The <code>--ccdb-path</code> option of the ccdb-populator-workflow allows to define the CCDB destination (e.g. <code>--ccdb-path localhost:8080</code>).</p>
<p>By default the <code>ccdb-populator-workflow</code> will upload to the CCDB the inputs with any <code>SubSpec</code>. There is a possibility to run with multiple <code>ccdb-populators</code>, e.g. each one writing to particular CCDB server (this might be needed e.g. to populate the production CCDB and the transient CCDB for DCS exchange, with the same or different objects). This can be done by piping two populators, one of which should have device name modified. Additionally, one can pass an option for each populator to process only inputs with specific <code>SubSpecs</code>. E.g. if your calibration device sends to the output </p><div class="fragment"><div class="line">output.snapshot(Output{o2::calibration::Utils::gDataOriginCDBPayload, &quot;ObjA&quot;, 0}, *imageA.get());</div>
<div class="line">output.snapshot(Output{o2::calibration::Utils::gDataOriginCDBWrapper, &quot;ObjA&quot;, 0}, wA);</div>
<div class="line">output.snapshot(Output{o2::calibration::Utils::gDataOriginCDBPayload, &quot;ObjB&quot;, 1}, *imageB.get());</div>
<div class="line">output.snapshot(Output{o2::calibration::Utils::gDataOriginCDBWrapper, &quot;ObjB&quot;, 1}, wB);</div>
<div class="line">output.snapshot(Output{o2::calibration::Utils::gDataOriginCDBPayload, &quot;ObjC&quot;, 2}, *imageC.get());</div>
<div class="line">output.snapshot(Output{o2::calibration::Utils::gDataOriginCDBWrapper, &quot;ObjC&quot;, 2}, wC);</div>
</div><!-- fragment --><p> in the workflow defined as: </p><div class="fragment"><div class="line">&lt;your_workflow&gt; | o2-calibration-ccdb-populator-workflow --ccdb-path=&quot;http://localhost:8080&quot; --name-extention loc  --sspec-min 1 --sspec-max 10 |</div>
<div class="line">o2-calibration-ccdb-populator-workflow --sspec-min 0 --sspec-max 1  -b</div>
</div><!-- fragment --><p> then the <code>ObjA</code> will be uploaded only to the default server (<code><a href="http://alice-ccdb.cern.ch">http://alice-ccdb.cern.ch</a></code>), <code>ObjB</code> will be uploaded to both default and <code>local</code> server and <code>ObjC</code> will be uploaded to the <code>local</code> server only.</p>
<p>By default the <code>ccdb-populator-workflow</code> will not produce <code>fatal</code> on failed upload. To require it an option <code>--fatal-on-failure</code> can be used.</p>
<p>By default the <code>ccdb-populator-workflow</code> uploads objects as it gets them. In case there is a danger that objects of the same URL will arrive in the order not sorted in SOV (which may lead to screaning of the object with later SOV by other object if earlier ROF) one can use an option <code>--ordering-latency &lt;N milliseconds&gt;</code> of the <code>ccdb-populator-workflow</code>. Then every incoming object will be buffered and uploaded only if no object with the same CCDB path and earlier start of validity was received in preceding N milliseconds. All remaining cached objects are uploaded at EOR (or stop() method call).</p>
<ul>
<li><a class="el" href="../../d4/d7a/refDetectorsCalibrationtestMacros.html">Detectors/Calibration/testMacros</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d0/d2f/refDetectors.html">Module &#39;Detectors&#39;</a></li>
    <li class="footer">Generated on Sat Feb 21 2026 17:59:16 for Project by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
